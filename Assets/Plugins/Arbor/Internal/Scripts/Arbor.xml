<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Arbor</name>
    </assembly>
    <members>
        <member name="T:Arbor.AddBehaviourMenu">
            <summary>
            Attribute that specifies the name of at AddBehaviour menu.
            </summary>
        </member>
        <member name="F:Arbor.AddBehaviourMenu.localization">
            <summary>
            Flag for localization. If true, convert to word of each language with menuName as key.
            </summary>
        </member>
        <member name="P:Arbor.AddBehaviourMenu.menuName">
            <summary>
            Menu name
            </summary>
        </member>
        <member name="M:Arbor.AddBehaviourMenu.#ctor(System.String)">
            <summary>
            AddBehaviourMenu constructor
            </summary>
            <param name="menuName">
            Menu name.
            <list type="bullet">
            <item><description>Hierarchized with "/" separator.</description></item>
            <item><description>If it is empty or null it is not displayed in the list.</description></item>
            </list>
            </param>
        </member>
        <member name="T:Arbor.AddCalculatorMenu">
            <summary>
            Attribute that specifies the name of at AddBehaviour menu.
            </summary>
        </member>
        <member name="P:Arbor.AddCalculatorMenu.menuName">
            <summary>
            Menu name
            </summary>
        </member>
        <member name="M:Arbor.AddCalculatorMenu.#ctor(System.String)">
            <summary>
            AddCalculatorMenu constructor
            </summary>
            <param name="menuName">
            Menu name.
            <list type="bullet">
            <item><description>Hierarchized with "/" separator.</description></item>
            <item><description>If it is empty or null it is not displayed in the list.</description></item>
            </list>
            </param>
        </member>
        <member name="T:Arbor.AddVariableMenu">
            <summary>
            AAttribute that specifies the path in ParameterContainer's parameter addition menu.
            </summary>
        </member>
        <member name="P:Arbor.AddVariableMenu.menuName">
            <summary>
            Menu name
            </summary>
        </member>
        <member name="M:Arbor.AddVariableMenu.#ctor(System.String)">
            <summary>
            AddVariableMenu constructor
            </summary>
            <param name="menuName">
            Menu name.
            <list type="bullet">
            <item><description>Hierarchized with "/" separator.</description></item>
            <item><description>If it is empty or null it is not displayed in the list.</description></item>
            </list>
            </param>
        </member>
        <member name="T:Arbor.AnimatorBoolParameterReference">
            <summary>
            A reference to the Boolean parameter of Animator.
            </summary>
        </member>
        <member name="M:Arbor.AnimatorBoolParameterReference.Set(System.Boolean)">
            <summary>
            Set the value.
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.AnimatorBoolParameterReference.Get">
            <summary>
            Get the value.
            </summary>
            <returns>Value</returns>
        </member>
        <member name="T:Arbor.AnimatorFloatParameterReference">
            <summary>
            A reference to the float parameter of Animator.
            </summary>
        </member>
        <member name="M:Arbor.AnimatorFloatParameterReference.Set(System.Single)">
            <summary>
            Set the value.
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.AnimatorFloatParameterReference.Set(System.Single,System.Single,System.Single)">
            <summary>
            Set the value.
            </summary>
            <param name="value">Value</param>
            <param name="dampTime">Damp Time</param>
            <param name="deltaTime">Delta Time</param>
        </member>
        <member name="M:Arbor.AnimatorFloatParameterReference.Get">
            <summary>
            Get the value.
            </summary>
            <returns>Value</returns>
        </member>
        <member name="T:Arbor.AnimatorIntParameterReference">
            <summary>
            A reference to the int parameter of Animator.
            </summary>
        </member>
        <member name="M:Arbor.AnimatorIntParameterReference.Set(System.Int32)">
            <summary>
            Set the value.
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.AnimatorIntParameterReference.Get">
            <summary>
            Get the value.
            </summary>
            <returns>Value</returns>
        </member>
        <member name="T:Arbor.AnimatorParameterReference">
            <summary>
            Reference Animator parameters.
            </summary>
        </member>
        <member name="F:Arbor.AnimatorParameterReference.animator">
            <summary>
            Animator parameters are stored.
            </summary>
        </member>
        <member name="F:Arbor.AnimatorParameterReference.name">
            <summary>
            Parameter name.
            </summary>
        </member>
        <member name="F:Arbor.AnimatorParameterReference.type">
            <summary>
            Parameter type.
            </summary>
        </member>
        <member name="T:Arbor.AnimatorTriggerParameterReference">
            <summary>
            A reference to the Boolean parameter of Animator.
            </summary>
        </member>
        <member name="M:Arbor.AnimatorTriggerParameterReference.Set">
            <summary>
            Set the trigger.
            </summary>
        </member>
        <member name="M:Arbor.AnimatorTriggerParameterReference.Reset">
            <summary>
            Reset the trigger.
            </summary>
        </member>
        <member name="T:Arbor.ArborFSMInternal">
            <summary>
            Internal class of <see cref="!:Arbor.ArborFSM" />.
            To actually attach to GameObject is to use the <see cref = "!:Arbor.ArborFSM" />.
            </summary>
        </member>
        <member name="F:Arbor.ArborFSMInternal.playOnStart">
            <summary>
            Flag to be played at the start.
            </summary>
        </member>
        <member name="F:Arbor.ArborFSMInternal.updateSettings">
            <summary>
            Settings related to updating.
            </summary>
        </member>
        <member name="P:Arbor.ArborFSMInternal.playState">
            <summary>
            Play state
            </summary>
        </member>
        <member name="P:Arbor.ArborFSMInternal.fsmName">
            <summary>
            The FSM name.<br/>
            It is used for identification and retrieval when there is more than one FSM in one GameObject.
            </summary>
        </member>
        <member name="P:Arbor.ArborFSMInternal.startStateID">
            <summary>
            Gets the start state identifier.
            </summary>
            <value>
            The start state identifier.
            </value>
        </member>
        <member name="P:Arbor.ArborFSMInternal.currentState">
            <summary>
            Gets <see cref="T:Arbor.State" /> of the current.
            </summary>
            <value>
            <see cref="T:Arbor.State" /> of the current.
            </value>
        </member>
        <member name="P:Arbor.ArborFSMInternal.prevTransitionState">
            <summary>
            Prev state
            </summary>
        </member>
        <member name="P:Arbor.ArborFSMInternal.nextTransitionState">
            <summary>
            Next state
            </summary>
        </member>
        <member name="P:Arbor.ArborFSMInternal.nextState">
            <summary>
            Gets the transition reserved <see cref="T:Arbor.State" />.
            </summary>
            <value>
            Transition reserved <see cref="T:Arbor.State" />.
            </value>
        </member>
        <member name="P:Arbor.ArborFSMInternal.reservedState">
            <summary>
            Gets the transition reserved <see cref="T:Arbor.State" />.
            </summary>
            <value>
            Transition reserved <see cref="T:Arbor.State" />.
            </value>
        </member>
        <member name="P:Arbor.ArborFSMInternal.stateCount">
            <summary>
             Get a count of State.
            </summary>
        </member>
        <member name="P:Arbor.ArborFSMInternal.stateLinkRerouteNodes">
            <summary>
            StateLinkRerouteNode List
            </summary>
        </member>
        <member name="M:Arbor.ArborFSMInternal.IndexOfStateLinkHistory(Arbor.StateLink)">
            <summary>
            Retrieve the index in the history that transited by the specified StateLink.
            </summary>
            <param name="stateLink">StateLink to acquire</param>
            <returns>Index of history. -1 is not eligible. Larger values indicate older transitions.</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.GetStateFromIndex(System.Int32)">
            <summary>
            Get State from index.
            </summary>
            <param name="index">Index</param>
            <returns>State</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.GetStateIndex(Arbor.State)">
            <summary>
            Get State index.
            </summary>
            <param name="state">State</param>
            <returns>Index. If not, it returns -1.</returns>
        </member>
        <member name="P:Arbor.ArborFSMInternal.states">
            <summary>
            Gets all of <see cref="T:Arbor.State" />.
            </summary>
            <value>
            Array of <see cref="T:Arbor.State" />.
            </value>
        </member>
        <member name="M:Arbor.ArborFSMInternal.GetStateFromID(System.Int32)">
            <summary>
            Gets <see cref="T:Arbor.State" /> from the state identifier.
            </summary>
            <param name="stateID">The state identifier.</param>
            <returns>Found <see cref = "T:Arbor.State" />. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.GetState(Arbor.StateLink)">
            <summary>
            Gets <see cref="T:Arbor.State" /> from the StateLink.
            </summary>
            <param name="stateLink">StateLink</param>
            <returns>Found <see cref = "T:Arbor.State" />. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.CreateState(System.Int32,System.Boolean)">
            <summary>
            Create state.
            </summary>
            <param name="nodeID">Node ID</param>
            <param name="resident">Resident whether flags.</param>
            <returns>The created state. If the node ID is not unique, return null without creating it.</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.CreateState(System.Boolean)">
            <summary>
            Create state.
            </summary>
            <param name="resident">Resident whether flags.</param>
            <returns>The created state.</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.CreateState">
            <summary>
            Create state.
            </summary>
            <returns>The created state.</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.FindState(System.String)">
            <summary>
            Search state by name.
            </summary>
            <param name="stateName">The name of the search state.</param>
            <returns>Found state. Return null if not.</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.FindStates(System.String)">
            <summary>
            Search state by name.
            </summary>
            <param name="stateName">The name of the search state.</param>
            <returns>Array of found state.</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.FindStateContainsBehaviour(Arbor.StateBehaviour)">
            <summary>
            Acquisition of states StateBehaviour belongs.
            </summary>
            <param name="behaviour">StateBehaviour</param>
            <returns>States StateBehaviour belongs. Return null if not.</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.DeleteState(Arbor.State)">
            <summary>
            Delete state.
            </summary>
            <param name="state">State that you want to delete.</param>
            <returns>true if deleted</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.CreateStateLinkRerouteNode(UnityEngine.Vector2,System.Int32,UnityEngine.Color)">
            <summary>
            Create StateLinkRerouteNode.
            </summary>
            <param name="position">Node position</param>
            <param name="nodeID">Node ID</param>
            <param name="lineColor">Line Color</param>
            <returns>The created StateLinkRerouteNode</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.CreateStateLinkRerouteNode(UnityEngine.Vector2,System.Int32)">
            <summary>
            Create StateLinkRerouteNode.
            </summary>
            <param name="position">Node position</param>
            <param name="nodeID">Node ID</param>
            <returns>The created StateLinkRerouteNode</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.CreateStateLinkRerouteNode(UnityEngine.Vector2,UnityEngine.Color)">
            <summary>
            Create StateLinkRerouteNode.
            </summary>
            <param name="position">Node position</param>
            <param name="lineColor">Line Color</param>
            <returns>The created StateLinkRerouteNode</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.CreateStateLinkRerouteNode(UnityEngine.Vector2)">
            <summary>
            Create StateLinkRerouteNode.
            </summary>
            <param name="position">Node position</param>
            <returns>The created StateLinkRerouteNode</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.OnDeleteNode(Arbor.Node)">
            <summary>
            Delete node.
            </summary>
            <param name="node">The node to delete</param>
            <returns>Returns true if deleted, false otherwise.</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.OnValidate">
            <summary>
            See MonoBehaviour.OnValidate.
            </summary>
        </member>
        <member name="M:Arbor.ArborFSMInternal.OnReset">
            <summary>
            Reset or create callback.
            </summary>
        </member>
        <member name="M:Arbor.ArborFSMInternal.Play">
            <summary>
            Start playing the state machine.
            </summary>
        </member>
        <member name="M:Arbor.ArborFSMInternal.Stop">
            <summary>
            Stopping playback of the state machine.
            </summary>
        </member>
        <member name="M:Arbor.ArborFSMInternal.Pause">
            <summary>
            Pause playback of the state machine.
            </summary>
        </member>
        <member name="M:Arbor.ArborFSMInternal.Resume">
            <summary>
            Resume playing state machine.
            </summary>
        </member>
        <member name="M:Arbor.ArborFSMInternal.ExecuteUpdate(System.Boolean)">
            <summary>
            Perform an update.
            Please call this method at any timing when UpdateSettings.type is Manual.
            </summary>
            <param name="autoExecuteLateUpdate">Flag for ExecuteLateUpdate automatically</param>
        </member>
        <member name="M:Arbor.ArborFSMInternal.ExecuteLateUpdate">
            <summary>
            Perform an LateUpdate.
            Please call this method at any timing when UpdateSettings.type is Manual.
            </summary>
        </member>
        <member name="M:Arbor.ArborFSMInternal.Transition(Arbor.State,Arbor.TransitionTiming)">
            <summary>
            State transition
            </summary>
            <param name="nextState">Destination state.</param>
            <param name="transitionTiming">Transition timing.</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.Transition(Arbor.State,System.Boolean)">
            <summary>
            State transition
            </summary>
            <param name="nextState">Destination state.</param>
            <param name="immediateTransition">Whether or not to transition immediately. If false I will transition to the end of the current frame (when LateUpdate).</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.Transition(Arbor.State)">
            <summary>
            State transition. Timing to actually transition current frame last (when LateUpdate).
            </summary>
            <param name="nextState">Destination state.</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.Transition(System.Int32,Arbor.TransitionTiming)">
            <summary>
            State transition
            </summary>
            <param name="nextStateID">State ID for the transition destination.</param>
            <param name="transitionTiming">Transition timing.</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.Transition(System.Int32,System.Boolean)">
            <summary>
            State transition
            </summary>
            <param name="nextStateID">State ID for the transition destination.</param>
            <param name="immediateTransition">Whether or not to transition immediately. If false I will transition to the end of the current frame (when LateUpdate).</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.Transition(System.Int32)">
            <summary>
            State transition. Timing to actually transition current frame last (when LateUpdate).
            </summary>
            <param name="nextStateID">State ID for the transition destination.</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.Transition(Arbor.StateLink,Arbor.TransitionTiming)">
            <summary>
            State transition
            </summary>
            <param name="nextStateLink">The destination of transition.</param>
            <param name="transitionTiming">Transition timing.</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.Transition(Arbor.StateLink,System.Boolean)">
            <summary>
            State transition
            </summary>
            <param name="nextStateLink">The destination of transition.</param>
            <param name="immediateTransition">Whether or not to transition immediately. If false I will transition to the end of the current frame (when LateUpdate).</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.Transition(Arbor.StateLink)">
            <summary>
            State transition. Timing to actually transition current frame last (when LateUpdate).
            </summary>
            <param name="nextStateLink">The destination of transition.</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.ArborFSMInternal.SendTrigger(System.String)">
            <summary>
            Sending of trigger
            </summary>
            <param name="message">Message to be sent</param>
        </member>
        <member name="T:Arbor.ArborReferenceUtility">
            <summary>
            Arbor reference utility class
            </summary>
        </member>
        <member name="F:Arbor.ArborReferenceUtility.docUrl">
            <summary>
            Document URL
            </summary>
        </member>
        <member name="F:Arbor.ArborReferenceUtility.componentUrl">
            <summary>
            Component Document URL
            </summary>
        </member>
        <member name="T:Arbor.AttributeHelper">
            <summary>
            A helper class for Attribute.
            </summary>
        </member>
        <member name="M:Arbor.AttributeHelper.GetAttributes(System.Reflection.MemberInfo)">
            <summary>
            Get Attributes.
            </summary>
            <param name="member">MemberInfo</param>
            <returns>Attributes</returns>
        </member>
        <member name="M:Arbor.AttributeHelper.GetAttribute(System.Reflection.MemberInfo,System.Type)">
            <summary>
            Get Attribute (generic)
            </summary>
            <param name="member">MemberInfo</param>
            <param name="targetType">Target Type</param>
            <returns>Attribute</returns>
        </member>
        <member name="M:Arbor.AttributeHelper.GetAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            Get Attribute (generic)
            </summary>
            <typeparam name="T">Target Type</typeparam>
            <param name="member">MemberInfo</param>
            <returns>Attribute</returns>
        </member>
        <member name="M:Arbor.AttributeHelper.HasAttribute(System.Reflection.MemberInfo,System.Type)">
            <summary>
            Whether has Attribute
            </summary>
            <param name="member">MemberInfo</param>
            <param name="targetType">Target Type</param>
            <returns>Whether has attribute.</returns>
        </member>
        <member name="M:Arbor.AttributeHelper.HasAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            Whether has Attribute
            </summary>
            <typeparam name="T">Target Type</typeparam>
            <param name="member">MemberInfo</param>
            <returns>Whether has attribute.</returns>
        </member>
        <member name="T:Arbor.BehaviourHelp">
            <summary>
            Attribute that specifies the URL to be displayed from the Help button of StateBehaviour.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourHelp.url">
            <summary>
            Url to display in browser when pressing help button
            </summary>
        </member>
        <member name="M:Arbor.BehaviourHelp.#ctor(System.String)">
            <summary>
            BehaviourHelp constructor
            </summary>
            <param name="url">Help page url</param>
        </member>
        <member name="T:Arbor.BehaviourTitle">
            <summary>
            Attribute that specifies the title to display the StateBehaviour.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTitle.localization">
            <summary>
            Flag for localization. If true, convert to word of each language with menuName as key.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTitle.titleName">
            <summary>
            Title name
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTitle.#ctor(System.String)">
            <summary>
            BehaviourTitle constructor
            </summary>
            <param name="titleName">Title name</param>
        </member>
        <member name="T:Arbor.BehaviourTree.AbortFlags">
            <summary>
            Abort flag
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.AbortFlags.Self">
            <summary>
            Abort self, and any sub-trees running under this node.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.AbortFlags.LowerPriority">
            <summary>
            Abort any nodes with lower priority than this node.
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.ActionBehaviour">
            <summary>
            Class that defines the behavior of the action. Inherited and to use.
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.AddBehaviourMenu" /></description></item>
            <item><description><see cref="T:Arbor.HideBehaviour" /></description></item>
            <item><description><see cref="T:Arbor.BehaviourTitle" /></description></item>
            <item><description><see cref="T:Arbor.BehaviourHelp" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Arbor.BehaviourTree.ActionBehaviour.actionNode">
            <summary>
            Get the ActionNode.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.ActionBehaviour.FinishExecute(System.Boolean)">
            <summary>
            Finish Execute.
            </summary>
            <param name="result">Execute result.</param>
        </member>
        <member name="M:Arbor.BehaviourTree.ActionBehaviour.OnExecute">
            <summary>
            Called when executing.
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.ActionNode">
            <summary>
            The node that executes the action
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.ActionNode.parentLink">
            <summary>
            Link to parent node
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.ActionNode.name">
            <summary>
            Node name.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.ActionNode.#ctor(Arbor.NodeGraph,System.Int32,System.Type)">
            <summary>
            Please use the <see cref = "M:Arbor.BehaviourTree.BehaviourTreeInternal.CreateAction(UnityEngine.Vector2,System.Type)" /> ActionNode creating.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.ActionNode.CreateActionBehaviour(System.Type)">
            <summary>
            Create a ActionBehaviour. Use it in the editor.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.ActionNode.HasParentLinkSlot">
            <summary>
            Whether this node has a NodeLinkSlot to parent.
            </summary>
            <returns>True if it has a NodeLinkSlot to parent, false otherwise.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.ActionNode.GetParentLinkSlot">
            <summary>
            Get NodeLinkSlot to parent.
            </summary>
            <returns>NodeLinkSlot to parent</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.ActionNode.HasChildLinkSlot">
            <summary>
            Whether this node has a NodeLinkSlot to child.
            </summary>
            <returns>True if it has a NodeLinkSlot to child, false otherwise.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.ActionNode.OnExecute">
            <summary>
            Called when executing.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.ActionNode.GetName">
            <summary>
            Get node name.
            </summary>
            <returns>Node name</returns>
        </member>
        <member name="T:Arbor.BehaviourTree.ActionNodeList">
            <summary>
            List of action nodes
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.BehaviourTreeInternal">
            <summary>
            Internal class of <see cref="N:Arbor.BehaviourTree" />.
            To actually attach to GameObject is to use the <see cref = "N:Arbor.BehaviourTree" />.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.BehaviourTreeInternal.playOnStart">
            <summary>
            Flag to be played at the start.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.BehaviourTreeInternal.restartOnFinish">
            <summary>
            Flag to restart at finish.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.BehaviourTreeInternal.updateSettings">
            <summary>
            Settings related to updating.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.BehaviourTreeInternal.executionSettings">
            <summary>
            Settings related to execution.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.BehaviourTreeInternal.playState">
            <summary>
            Play state
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.BehaviourTreeInternal.nodeBranchies">
            <summary>
            Get NodeBranch List
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.BehaviourTreeInternal.compositeNodes">
            <summary>
            Get CompositeNode List
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.BehaviourTreeInternal.actionNodes">
            <summary>
            Get ActionNode List
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.BehaviourTreeInternal.rootNode">
            <summary>
            Get RootNode
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.BehaviourTreeInternal.currentNode">
            <summary>
            Current active node
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.IsRevaluation(Arbor.BehaviourTree.TreeNodeBase)">
            <summary>
            It returns the reevaluation node.
            </summary>
            <param name="node">Node</param>
            <returns>Returns true if it is a reevaluation node.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.Play">
            <summary>
            Start playing the behaviour tree.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.Stop">
            <summary>
            Stopping playback of the behaviour tree.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.Pause">
            <summary>
            Pause playback of the behaviour tree.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.Resume">
            <summary>
            Resume playing behaviour tree.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.CreateComposite(UnityEngine.Vector2,System.Int32,System.Type)">
            <summary>
            Create Composite.
            </summary>
            <param name="position">Node position</param>
            <param name="nodeID">Node ID</param>
            <param name="classType">CompositeBehaviour type</param>
            <returns>The created coomposite node.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.CreateComposite(UnityEngine.Vector2,System.Type)">
            <summary>
            Create Composite.
            </summary>
            <param name="position">Node position</param>
            <param name="classType">CompositeBehaviour type</param>
            <returns>The created coomposite node.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.CreateAction(UnityEngine.Vector2,System.Int32,System.Type)">
            <summary>
            Create ActionNode.
            </summary>
            <param name="position">Node position</param>
            <param name="nodeID">Node ID</param>
            <param name="classType">ActionBehaviour type</param>
            <returns>The created action node.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.CreateAction(UnityEngine.Vector2,System.Type)">
            <summary>
            Create ActionNode.
            </summary>
            <param name="position">Node position</param>
            <param name="classType">ActionBehaviour type</param>
            <returns>The created action node.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.OnReset">
            <summary>
            Reset or create callback.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.CalculatePriority">
            <summary>
            Calculate priority of nodes.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.OnDeleteNode(Arbor.Node)">
            <summary>
            Delete node.
            </summary>
            <param name="node">The node to delete</param>
            <returns>Returns true if deleted, false otherwise.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.OnValidateNodes">
            <summary>
            Called when the node is changed.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.CheckLoop(Arbor.BehaviourTree.TreeNodeBase,Arbor.BehaviourTree.TreeNodeBase)">
            <summary>
            Check whether the connection of the node is looping.
            </summary>
            <param name="parentNode">Parent node</param>
            <param name="childNode">Child node</param>
            <returns>Returns true if it is looping.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.ConnectBranch(System.Int32,Arbor.BehaviourTree.TreeNodeBase,Arbor.BehaviourTree.TreeNodeBase)">
            <summary>
            Connect NodeBranch.
            </summary>
            <param name="branchID">ID of the NodeBranch to be created</param>
            <param name="parentNode">Parent node.</param>
            <param name="childNode">Child node.</param>
            <returns>Connected NodeBranch</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.ConnectBranch(Arbor.BehaviourTree.TreeNodeBase,Arbor.BehaviourTree.TreeNodeBase)">
            <summary>
            Connect NodeBranch.
            </summary>
            <param name="parentNode">Parent node.</param>
            <param name="childNode">Child node.</param>
            <returns>Connected NodeBranch</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.DisconnectBranch(Arbor.BehaviourTree.NodeBranch)">
            <summary>
            Disconnect NodeBranch
            </summary>
            <param name="branch">Disconnect NodeBranch</param>
        </member>
        <member name="M:Arbor.BehaviourTree.BehaviourTreeInternal.Execute">
            <summary>
            Execute manually.
            Please call this method at any timing when UpdateSettings.type is Manual.
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.CompositeBehaviour">
            <summary>
            Class that defines the behavior of the composite. Inherited and to use.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.CompositeBehaviour.compositeNode">
            <summary>
            Get the CompositeNode.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.CompositeBehaviour.GetBeginIndex">
            <summary>
            Get the child node index to be executed at the start.
            </summary>
            <returns>Index of child node</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.CompositeBehaviour.GetNextIndex(System.Int32)">
            <summary>
            Get the child node index to be executed.
            </summary>
            <param name="currentIndex">Current index</param>
            <returns>Index of child node</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.CompositeBehaviour.GetInterruptIndex(Arbor.BehaviourTree.TreeNodeBase)">
            <summary>
            Get the index of the interrupted node.
            </summary>
            <param name="node">Interrupted node</param>
            <returns>Index of child node</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.CompositeBehaviour.CanExecute(Arbor.BehaviourTree.NodeStatus)">
            <summary>
            It is judged whether it can be executed.
            </summary>
            <param name="childStatus">State of child node</param>
            <returns>Returns true if it can be executed.</returns>
        </member>
        <member name="T:Arbor.BehaviourTree.CompositeNode">
            <summary>
            This node controls the execution of child nodes.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.CompositeNode.parentLink">
            <summary>
            Link to parent node
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.CompositeNode.childrenLink">
            <summary>
            Link to child nodes.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.CompositeNode.name">
            <summary>
            Node name.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.CompositeNode.#ctor(Arbor.NodeGraph,System.Int32,System.Type)">
            <summary>
            Please use the <see cref = "M:Arbor.BehaviourTree.BehaviourTreeInternal.CreateComposite(UnityEngine.Vector2,System.Type)" /> CompositeNode creating.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.CompositeNode.CreateCompositeBehaviour(System.Type)">
            <summary>
            Create a CompositeBehaviour. Use it in the editor.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.CompositeNode.HasParentLinkSlot">
            <summary>
            Whether this node has a NodeLinkSlot to parent.
            </summary>
            <returns>True if it has a NodeLinkSlot to parent, false otherwise.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.CompositeNode.GetParentLinkSlot">
            <summary>
            Get NodeLinkSlot to parent.
            </summary>
            <returns>NodeLinkSlot to parent</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.CompositeNode.HasChildLinkSlot">
            <summary>
            Whether this node has a NodeLinkSlot to child.
            </summary>
            <returns>True if it has a NodeLinkSlot to child, false otherwise.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.CompositeNode.OnExecute">
            <summary>
            Called when executing.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.CompositeNode.GetName">
            <summary>
            Get node name.
            </summary>
            <returns>Node name</returns>
        </member>
        <member name="T:Arbor.BehaviourTree.CompositeNodeList">
            <summary>
            List of composite nodes
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.Decorator">
            <summary>
            A class that defines decoration for composite nodes and action nodes. Inherit and use it.
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.AddBehaviourMenu" /></description></item>
            <item><description><see cref="T:Arbor.HideBehaviour" /></description></item>
            <item><description><see cref="T:Arbor.BehaviourTitle" /></description></item>
            <item><description><see cref="T:Arbor.BehaviourHelp" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Arbor.BehaviourTree.Decorator._AbortFlags">
            <summary>
            Abort Flags.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.Decorator.behaviourEnabled">
            <summary>
            Gets or sets a value indicating whether [behaviour enabled].
            </summary>
            <value>
              <c>true</c> if [behaviour enabled]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Arbor.BehaviourTree.Decorator.abortFlags">
            <summary>
            Abort flags
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.Decorator.isRevaluation">
            <summary>
            It returns whether to reevaluate.
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.Decorator.Condition">
            <summary>
            The condition of the decorator
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.Decorator.Condition.None">
            <summary>
            No condition
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.Decorator.Condition.Success">
            <summary>
            Success
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.Decorator.Condition.Failure">
            <summary>
            Failure
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.Decorator.currentCondition">
            <summary>
            Current condition
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.Decorator.Create(Arbor.Node,System.Type)">
            <summary>
            Create Decorator
            </summary>
            <param name="node">Node</param>
            <param name="type">Decorator type</param>
            <returns>Created Decorator.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.Decorator.Create``1(Arbor.Node)">
            <summary>
            Create Decorator
            </summary>
            <typeparam name="Type">Decorator type</typeparam>
            <param name="node">Node</param>
            <returns>Created Decorator.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.Decorator.HasConditionCheck">
            <summary>
            It is judged whether Condition Check should be performed.
            </summary>
            <remarks>
            It returns true by default.
            To invalidate, please override and return false.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Arbor.BehaviourTree.Decorator.OnConditionCheck">
            <summary>
            Perform ConditionCheck.
            </summary>
            <returns>Returns true if it matches the condition, false if it does not match.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.Decorator.OnFinishExecute(System.Boolean)">
            <summary>
            FinishExecute callback.<br />
            You can change the result of the execution result.
            </summary>
            <param name="result">Execution result.</param>
            <returns>Changed result.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.Decorator.OnRepeatCheck">
            <summary>
            Callback to decide whether to repeat again when the self node finishes.
            </summary>
            <returns>Returns true if to repeat, false otherwise.</returns>
        </member>
        <member name="T:Arbor.BehaviourTree.DecoratorList">
            <summary>
            List of decorators
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.ExecutionSettings">
            <summary>
            Behavior tree execution settings.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.ExecutionSettings.type">
            <summary>
            Execution type
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.ExecutionSettings.maxCount">
            <summary>
            Maximum count of the action to execute.
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.ExecutionType">
            <summary>
            Behavior tree execution type.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.ExecutionType.UntilRunning">
            <summary>
            Execute all actions until TreeNodeBase.status is NodeStatus.Running.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.ExecutionType.Count">
            <summary>
            Specify the maximum count of actions to execute.
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.NodeBranch">
            <summary>
            Branch classes between nodes of Behavior Tree
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.NodeBranch.branchID">
            <summary>
            Branch ID
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.NodeBranch.parentNodeID">
            <summary>
            Parent node ID
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.NodeBranch.childNodeID">
            <summary>
            Child node ID
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.NodeBranch.bezier">
            <summary>
            Bezier of the connection line. Use it in the editor.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.NodeBranch.isActive">
            <summary>
            Flag for active or not. Use it in the editor.
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.NodeBranchies">
            <summary>
            List of NodeBranch
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.NodeBranchies.count">
            <summary>
             Get a count of NodeBranch.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.NodeBranchies.Item(System.Int32)">
            <summary>
            Get NodeBranch from index.
            </summary>
            <param name="index">Index</param>
        </member>
        <member name="M:Arbor.BehaviourTree.NodeBranchies.IndexOf(Arbor.BehaviourTree.NodeBranch)">
            <summary>
            Get NodeBranch index.
            </summary>
            <param name="branch">NodeBranch</param>
            <returns>Index. If not, it returns -1.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.NodeBranchies.GetUniqueBranchID">
            <summary>
            Get the ID of NodeBranch that is not being used
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.NodeBranchies.GetFromID(System.Int32)">
            <summary>
            Gets <see cref="T:Arbor.BehaviourTree.NodeBranch" /> from the branch identifier.
            </summary>
            <param name="branchID">The branch identifier.</param>
            <returns>Found <see cref = "T:Arbor.BehaviourTree.NodeBranch" />. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.NodeBranchies.Add(Arbor.BehaviourTree.NodeBranch)">
            <summary>
            Add a NodeBranch.
            </summary>
            <param name="nodeBranch">The NodeBranch to be added.</param>
        </member>
        <member name="M:Arbor.BehaviourTree.NodeBranchies.Remove(Arbor.BehaviourTree.NodeBranch)">
            <summary>
            Remove a node.
            </summary>
            <param name="nodeBranch">The NodeBranch to be removed.</param>
            <returns>Returns true if removed.</returns>
        </member>
        <member name="T:Arbor.BehaviourTree.NodeLinkSlot">
            <summary>
            Slot class for linking with Node.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.NodeLinkSlot.branchID">
            <summary>
            BranchID of NodeBranch
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.NodeStatus">
            <summary>
            Behavior tree node status
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.NodeStatus.Running">
            <summary>
            Running
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.NodeStatus.Success">
            <summary>
            Success
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.NodeStatus.Failure">
            <summary>
            Failure
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.RootNode">
            <summary>
            Root Node
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.RootNode.childNodeLink">
            <summary>
            Link to child nodes.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.RootNode.childNode">
            <summary>
            Get child node.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.RootNode.#ctor(Arbor.NodeGraph,System.Int32)">
            <summary>
            RootNode constructor
            </summary>
            <param name="nodeGraph">NodeGraph with this node</param>
            <param name="nodeID">Node ID</param>
            <remarks>
            RootNode is created automatically as soon as Behavior Tree is created.
            </remarks>
        </member>
        <member name="M:Arbor.BehaviourTree.RootNode.HasParentLinkSlot">
            <summary>
            Whether this node has a NodeLinkSlot to parent.
            </summary>
            <returns>True if it has a NodeLinkSlot to parent, false otherwise.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.RootNode.HasChildLinkSlot">
            <summary>
            Whether this node has a NodeLinkSlot to child.
            </summary>
            <returns>True if it has a NodeLinkSlot to child, false otherwise.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.RootNode.OnExecute">
            <summary>
            Called when executing.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.RootNode.IsDeletable">
            <summary>
            Returns whether or not it can be deleted.
            </summary>
            <returns>Returns true if it can be deleted.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.RootNode.GetName">
            <summary>
            Get node name.
            </summary>
            <returns>Node name</returns>
        </member>
        <member name="T:Arbor.BehaviourTree.Service">
            <summary>
            Class executed when its own node is active. Inherit and use it.
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.AddBehaviourMenu" /></description></item>
            <item><description><see cref="T:Arbor.HideBehaviour" /></description></item>
            <item><description><see cref="T:Arbor.BehaviourTitle" /></description></item>
            <item><description><see cref="T:Arbor.BehaviourHelp" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Arbor.BehaviourTree.Service.behaviourEnabled">
            <summary>
            Gets or sets a value indicating whether [behaviour enabled].
            </summary>
            <value>
              <c>true</c> if [behaviour enabled]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Arbor.BehaviourTree.Service.OnUpdate">
            <summary>
            Update of Service. It is called execution frame.
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.ServiceList">
            <summary>
            Service List
            </summary>
        </member>
        <member name="T:Arbor.BehaviourTree.TreeBehaviourNode">
            <summary>
            Base class of node with TreeNodeBehaviour
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.TreeBehaviourNode.behaviour">
            <summary>
            Main behaviour
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.TreeBehaviourNode.decoratorList">
            <summary>
            Decorator list
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.TreeBehaviourNode.serviceList">
            <summary>
            Service list
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.#ctor(Arbor.NodeGraph,System.Int32)">
            <summary>
            TreeBehaviourNode constructor
            </summary>
            <param name="nodeGraph">NodeGraph with this node</param>
            <param name="nodeID">Node ID</param>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.GetBehaviourObject">
            <summary>
            Get Main Behaviour Object.
            </summary>
            <returns>Main Behaviour Object</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.AddDecorator(System.Type)">
            <summary>
            Adds the Decorator.
            </summary>
            <param name="type">Type of add Decorator</param>
            <returns>Added Decorator</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.AddDecorator``1">
            <summary>
            Adds the Decorator.
            </summary>
            <typeparam name="T">Type of add Decorator</typeparam>
            <returns>Added Decorator</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.InsertDecorator(System.Int32,System.Type)">
            <summary>
            Insert the Decorator.
            </summary>
            <param name="index">Insertion destination index</param>
            <param name="type">Type of add Decorator</param>
            <returns>Inserted Decorator</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.InsertDecorator``1(System.Int32)">
            <summary>
            Insert the Decorator.
            </summary>
            <typeparam name="T">Type of insert Decorator</typeparam>
            <param name="index">Insertion destination index</param>
            <returns>Inserted Decorator</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.AddService(System.Type)">
            <summary>
            Adds the Service.
            </summary>
            <param name="type">Type of add Service</param>
            <returns>Added Service</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.AddService``1">
            <summary>
            Adds the Service.
            </summary>
            <typeparam name="T">Type of add Service</typeparam>
            <returns>Added Service</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.InsertService(System.Int32,System.Type)">
            <summary>
            Insert the Service.
            </summary>
            <param name="index">Insertion destination index</param>
            <param name="type">Type of add Service</param>
            <returns>Inserted Service</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.InsertService``1(System.Int32)">
            <summary>
            Insert the Service.
            </summary>
            <typeparam name="T">Type of insert Service</typeparam>
            <param name="index">Insertion destination index</param>
            <returns>Inserted Service</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.OnGraphChanged">
            <summary>
            Called when the NodeGraph to which the Node belongs has changed.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.IsContainsBehaviour(Arbor.NodeBehaviour)">
            <summary>
            Check if it contains NodeBehaviour.
            </summary>
            <param name="behaviour">Check NodeBehaviour</param>
            <returns>Returns true if it contains NodeBehaviour.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.MoveDecorator(System.Int32,Arbor.BehaviourTree.TreeBehaviourNode,System.Int32)">
            <summary>
            Move the order of Decorator.
            </summary>
            <param name="fromIndex">The moving want index.</param>
            <param name="toNode">The destination Node.</param>
            <param name="toIndex">The destination index.</param>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.MoveService(System.Int32,Arbor.BehaviourTree.TreeBehaviourNode,System.Int32)">
            <summary>
            Move the order of Service.
            </summary>
            <param name="fromIndex">The moving want index.</param>
            <param name="toNode">The destination Node.</param>
            <param name="toIndex">The destination index.</param>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.DestroyBehaviour">
            <summary>
            Destroy behaviour.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.DestroyAllBehaviour">
            <summary>
            Destroy all behaviour.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeBehaviourNode.SetBehaviour(Arbor.BehaviourTree.TreeNodeBehaviour)">
            <summary>
            Set Main Behaviour.
            </summary>
            <param name="behaviour">Behaviour</param>
        </member>
        <member name="T:Arbor.BehaviourTree.TreeNodeBase">
            <summary>
            Base class of Behavior Tree's node.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.TreeNodeBase.enablePriority">
            <summary>
            Returns true if it is traced from the root node and connected.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.TreeNodeBase.priority">
            <summary>
            The priority of the node.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.TreeNodeBase.behaviourTree">
            <summary>
            Gets the behaviour tree.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.TreeNodeBase.parentNode">
            <summary>
            Get parent node.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.TreeNodeBase.status">
            <summary>
            The state of the node.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.TreeNodeBase.isActive">
            <summary>
            Returns true if it is active.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeNodeBase.#ctor(Arbor.NodeGraph,System.Int32)">
            <summary>
            TreeNodeBase constructor
            </summary>
            <param name="nodeGraph">NodeGraph with this node</param>
            <param name="nodeID">Node ID</param>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeNodeBase.HasParentLinkSlot">
            <summary>
            Whether this node has a NodeLinkSlot to parent.
            </summary>
            <returns>True if it has a NodeLinkSlot to parent, false otherwise.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeNodeBase.GetParentLinkSlot">
            <summary>
            Get NodeLinkSlot to parent.
            </summary>
            <returns>NodeLinkSlot to parent</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeNodeBase.HasChildLinkSlot">
            <summary>
            Whether this node has a NodeLinkSlot to child.
            </summary>
            <returns>True if it has a NodeLinkSlot to child, false otherwise.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeNodeBase.OnExecute">
            <summary>
            Called when executing.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeNodeBase.IsDeletable">
            <summary>
            Returns whether or not it can be deleted.
            </summary>
            <returns>Returns true if it can be deleted.</returns>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeNodeBase.ToString">
            <summary>
            Convert node to string (for debugging).
            </summary>
            <returns>Converted string</returns>
        </member>
        <member name="T:Arbor.BehaviourTree.TreeNodeBehaviour">
            <summary>
            Base class that defines the behavior of TreeBehaviourNode.
            </summary>
        </member>
        <member name="F:Arbor.BehaviourTree.TreeNodeBehaviour.expanded">
            <summary>
            Expanded on ArborEditorWindow.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.TreeNodeBehaviour.behaviourTree">
            <summary>
            Gets the behaviour tree.
            </summary>
        </member>
        <member name="P:Arbor.BehaviourTree.TreeNodeBehaviour.treeNode">
            <summary>
            Get the TreeNodeBase.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeNodeBehaviour.OnInitializeEnabled">
            <summary>
            Called to perform enabled initialization.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeNodeBehaviour.OnAwake">
            <summary>
            This function is called when the own node becomes active for the first time.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeNodeBehaviour.OnStart">
            <summary>
            This function is called when the own node becomes active.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeNodeBehaviour.OnAbort">
            <summary>
            This function is called when the own node is aborted.
            </summary>
        </member>
        <member name="M:Arbor.BehaviourTree.TreeNodeBehaviour.OnEnd">
            <summary>
            This function is called when the own node ends.
            </summary>
        </member>
        <member name="T:Arbor.Bezier2D">
            <summary>
            Class to handle the two-dimensional cubic Bezier
            </summary>
        </member>
        <member name="P:Arbor.Bezier2D.startPosition">
            <summary>
            Starting point
            </summary>
        </member>
        <member name="P:Arbor.Bezier2D.startControl">
            <summary>
            Control point of the starting point
            </summary>
        </member>
        <member name="P:Arbor.Bezier2D.endPosition">
            <summary>
            End point
            </summary>
        </member>
        <member name="P:Arbor.Bezier2D.endControl">
            <summary>
            Control point of the end point
            </summary>
        </member>
        <member name="P:Arbor.Bezier2D.length">
            <summary>
            Length
            </summary>
        </member>
        <member name="P:Arbor.Bezier2D.isChanged">
            <summary>
            Whether it has been changed
            </summary>
        </member>
        <member name="M:Arbor.Bezier2D.#ctor">
            <summary>
            new Bezier2D.
            </summary>
        </member>
        <member name="M:Arbor.Bezier2D.#ctor(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            new Bezier2D.
            </summary>
            <param name="startPosition">Starting point</param>
            <param name="startControl">Control point of the end point</param>
            <param name="endPosition">End point</param>
            <param name="endControl">Control point of the end point</param>
        </member>
        <member name="M:Arbor.Bezier2D.#ctor(Arbor.Bezier2D)">
            <summary>
            new Bezier2D.
            </summary>
            <param name="bezier">Copy source Bezier2D</param>
        </member>
        <member name="M:Arbor.Bezier2D.SetStartPoint(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Set Start point.
            </summary>
            <param name="position">Position</param>
            <param name="control">Control point</param>
            <returns>true if changed.</returns>
        </member>
        <member name="M:Arbor.Bezier2D.SetEndPoint(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Set End point.
            </summary>
            <param name="position">Position</param>
            <param name="control">Control point</param>
            <returns>true if changed.</returns>
        </member>
        <member name="M:Arbor.Bezier2D.GetPoint(System.Single)">
            <summary>
            Get a position on the Bezier curve.
            </summary>
            <param name="t">0-1 of value</param>
        </member>
        <member name="M:Arbor.Bezier2D.GetClosestPoint(UnityEngine.Vector2,System.Single)">
            <summary>
            Get a closest point on the Bezier curve.
            </summary>
            <param name="pos">position</param>
            <param name="thresholdT">threshold of closest param.</param>
            <returns>Closest point</returns>
        </member>
        <member name="M:Arbor.Bezier2D.GetClosestParam(UnityEngine.Vector2,System.Single)">
            <summary>
            Get a closest point on the Bezier curve.
            </summary>
            <param name="pos">position</param>
            <param name="thresholdT">threshold of closest param.</param>
            <returns>Closest param</returns>
        </member>
        <member name="M:Arbor.Bezier2D.GetPoint(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
            <summary>
            Get a position on the Bezier curve.
            </summary>
            <param name="startPosition">Starting point</param>
            <param name="startControl">Control point of the starting point</param>
            <param name="endPosition">End point</param>
            <param name="endControl">Control point of the end point</param>
            <param name="t">0-1 of value</param>
        </member>
        <member name="M:Arbor.Bezier2D.GetLinearPoint(System.Single)">
            <summary>
            Get a position on the Bezier curve linear.
            </summary>
            <param name="t">0-1 of value</param>
        </member>
        <member name="M:Arbor.Bezier2D.Equals(Arbor.Bezier2D)">
            <summary>
            Returns whether this is equal to Bezier2D.
            </summary>
            <param name="bezier">Value of Bezier2D</param>
            <returns>Returns true if they are equal.</returns>
        </member>
        <member name="M:Arbor.Bezier2D.Equals(System.Object)">
            <summary>
            Returns whether this is equal to object.
            </summary>
            <param name="obj">object value</param>
            <returns>Returns true if they are equal.</returns>
        </member>
        <member name="M:Arbor.Bezier2D.GetHashCode">
            <summary>
            Get a hash code.
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="T:Arbor.BuiltInBehaviour">
            <summary>
            Attributes that define the built-in Behaviour. Arbor used internally.
            </summary>
        </member>
        <member name="T:Arbor.BuiltInCalculator">
            <summary>
            Attributes that define the built-in Calculator. Arbor used internally.
            </summary>
        </member>
        <member name="T:Arbor.BuiltInComponent">
            <summary>
            Attributes that define the built-in Component. Arbor used internally.
            </summary>
        </member>
        <member name="T:Arbor.Calculator">
            <summary>
            Class that defines the behavior of the State. Inherited and to use.
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.AddBehaviourMenu" /></description></item>
            <item><description><see cref="T:Arbor.HideBehaviour" /></description></item>
            <item><description><see cref="T:Arbor.BehaviourTitle" /></description></item>
            <item><description><see cref="T:Arbor.BehaviourHelp" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Arbor.Calculator.calculatorNode">
            <summary>
            Get the CalculatorNode.
            </summary>
        </member>
        <member name="P:Arbor.Calculator.calculatorID">
            <summary>
            Gets the Calculator identifier.
            </summary>
        </member>
        <member name="P:Arbor.Calculator.isDirty">
            <summary>
            Whether it has been changed.
            </summary>
        </member>
        <member name="M:Arbor.Calculator.OnCheckDirty">
            <summary>
            It is called when judging whether it has been changed.
            </summary>
            <returns>Returns true if it has been changed, false otherwise.</returns>
        </member>
        <member name="M:Arbor.Calculator.SetDirty">
            <summary>
            Call if you want call OnCalculate.
            </summary>
        </member>
        <member name="M:Arbor.Calculator.Awake">
            <summary>
            This function is called when the script instance is being loaded.
            </summary>
        </member>
        <member name="M:Arbor.Calculator.OnDestroy">
            <summary>
            This function is called when MonoBehaivour will be destroyed.
            </summary>
        </member>
        <member name="M:Arbor.Calculator.OnValidate">
            <summary>
            This function is called when the script is loaded or a value is changed in the inspector (Called in the editor only).
            </summary>
        </member>
        <member name="M:Arbor.Calculator.Calculate">
            <summary>
            It is calculated, if necessary.
            </summary>
        </member>
        <member name="M:Arbor.Calculator.OnCalculate">
            <summary>
            It called when it is calculated .
            </summary>
        </member>
        <member name="T:Arbor.CalculatorHelp">
            <summary>
            Attribute that specifies the URL to be displayed from the Help button of Calculator.
            </summary>
        </member>
        <member name="P:Arbor.CalculatorHelp.url">
            <summary>
            Url to display in browser when pressing help button
            </summary>
        </member>
        <member name="M:Arbor.CalculatorHelp.#ctor(System.String)">
            <summary>
            CalculatorHelp constructor
            </summary>
            <param name="url">Help page url</param>
        </member>
        <member name="T:Arbor.CalculatorNode">
            <summary>
            Class that represents a calculator
            </summary>
        </member>
        <member name="P:Arbor.CalculatorNode.calculatorID">
            <summary>
            Gets the calculator node identifier.
            </summary>
        </member>
        <member name="P:Arbor.CalculatorNode.calculator">
            <summary>
            Get the attached Calculator.
            </summary>
        </member>
        <member name="M:Arbor.CalculatorNode.GetObject">
            <summary>
            Get the Object of the attached Calculator
            </summary>
            <returns>The Object of the attached Calculator</returns>
        </member>
        <member name="M:Arbor.CalculatorNode.#ctor(Arbor.NodeGraph,System.Int32,System.Type)">
            <summary>
            CalculatorNode constructor
            </summary>
            <param name="nodeGraph">NodeGraph with this node</param>
            <param name="nodeID">Node ID</param>
            <param name="calculatorType">Calculator type</param>
            <remarks>
            Please use the <see cref = "M:Arbor.NodeGraph.CreateCalculator(System.Type)" /> Calculator Node creating.
            </remarks>
        </member>
        <member name="M:Arbor.CalculatorNode.CreateCalculator(System.Type)">
            <summary>
            Create a Calculator. Use it in the editor.
            </summary>
        </member>
        <member name="M:Arbor.CalculatorNode.OnGraphChanged">
            <summary>
            Called when the NodeGraph to which the Node belongs has changed.
            </summary>
        </member>
        <member name="M:Arbor.CalculatorNode.IsContainsBehaviour(Arbor.NodeBehaviour)">
            <summary>
            Check if it contains NodeBehaviour.
            </summary>
            <param name="behaviour">Check NodeBehaviour</param>
            <returns>Returns true if it contains NodeBehaviour.</returns>
        </member>
        <member name="T:Arbor.CalculatorTitle">
            <summary>
            Attribute that specifies the title to display the StateBehaviour.
            </summary>
        </member>
        <member name="P:Arbor.CalculatorTitle.titleName">
            <summary>
            Title name
            </summary>
        </member>
        <member name="M:Arbor.CalculatorTitle.#ctor(System.String)">
            <summary>
            CalculatorTitle constructor
            </summary>
            <param name="titleName">Title name</param>
        </member>
        <member name="T:Arbor.ClassConstraintInfo">
            <summary>
            Class constraint information
            </summary>
        </member>
        <member name="F:Arbor.ClassConstraintInfo.baseType">
            <summary>
            Base type
            </summary>
        </member>
        <member name="F:Arbor.ClassConstraintInfo.constraintAttribute">
            <summary>
            ClassTypeConstraintAttribute
            </summary>
        </member>
        <member name="F:Arbor.ClassConstraintInfo.constraintFieldInfo">
            <summary>
            FieldInfo of the field to which ClassTypeConstraintAttribute is given
            </summary>
        </member>
        <member name="F:Arbor.ClassConstraintInfo.slotTypeAttribute">
            <summary>
            SlotTypeAttribute
            </summary>
        </member>
        <member name="M:Arbor.ClassConstraintInfo.IsConstraintSatisfied(System.Type)">
            <summary>
            Determine whether the constraint is satisfied
            </summary>
            <param name="type">Determining type</param>
            <returns>Returns true if the constraint is satisfied.</returns>
        </member>
        <member name="M:Arbor.ClassConstraintInfo.GetConstraintBaseType">
            <summary>
            Get the base type of constraint.
            </summary>
            <returns>Return base type of constraint</returns>
        </member>
        <member name="M:Arbor.ClassConstraintInfo.GetConstraintTypeName">
            <summary>
            Returns the type name of the constraint.
            </summary>
            <returns>Type name of the constraint. Returns Any if there are no constraints.</returns>
        </member>
        <member name="T:Arbor.ClassTypeConstraintAttribute">
            <summary>
            A basic Attribute class that imposes a type constraint on a field.
            </summary>
            <remarks>
            Available classes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.ClassTypeReference"/></description></item>
            <item><description><see cref="T:Arbor.AnyParameterReference"/></description></item>
            <item><description><see cref="T:Arbor.ComponentParameterReference"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotAny"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotComponent"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotUnityObject"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Arbor.ClassTypeConstraintAttribute.GetBaseType(System.Reflection.FieldInfo)">
            <summary>
            It returns the base type of constraints.
            </summary>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>The base type of constraints</returns>
        </member>
        <member name="M:Arbor.ClassTypeConstraintAttribute.GetTypeName(System.Reflection.FieldInfo)">
            <summary>
            Returns the type name of the constraint.
            </summary>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>Type name of constraint</returns>
        </member>
        <member name="M:Arbor.ClassTypeConstraintAttribute.IsConstraintSatisfied(System.Type,System.Reflection.FieldInfo)">
            <summary>
            Whether the constraint is satisfied is judged.
            </summary>
            <param name="type">Determining type</param>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>Returns true if the constraint is satisfied.</returns>
        </member>
        <member name="T:Arbor.ClassExtendsAttribute">
            <summary>
            Attribute to restrict to classes inherited from the type specified for the field.
            </summary>
            <remarks>
            Available classes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.ClassTypeReference"/></description></item>
            <item><description><see cref="T:Arbor.AnyParameterReference"/></description></item>
            <item><description><see cref="T:Arbor.ComponentParameterReference"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotAny"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotComponent"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotUnityObject"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Arbor.ClassExtendsAttribute.GetBaseType(System.Reflection.FieldInfo)">
            <summary>
            It returns the base type of constraints.
            </summary>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>The base type of constraints</returns>
        </member>
        <member name="M:Arbor.ClassExtendsAttribute.#ctor(System.Type)">
            <summary>
            Create a ClassExtendsAttribute with a specified type.
            </summary>
            <param name="baseType">Basic type</param>
        </member>
        <member name="M:Arbor.ClassExtendsAttribute.IsConstraintSatisfied(System.Type,System.Reflection.FieldInfo)">
            <summary>
            Whether the constraint is satisfied is judged.
            </summary>
            <param name="type">Determining type</param>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>Returns true if the constraint is satisfied.</returns>
        </member>
        <member name="T:Arbor.ClassUnityObjectAttribute">
            <summary>
            Attribute to restrict to classes inherited from UnityEngine.Object for fields.
            </summary>
            <remarks>
            Except for classes inherited from NodeBehaviour. <br/>
            Available classes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.ClassTypeReference"/></description></item>
            <item><description><see cref="T:Arbor.AnyParameterReference"/></description></item>
            <item><description><see cref="T:Arbor.ComponentParameterReference"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotAny"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotComponent"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotUnityObject"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Arbor.ClassUnityObjectAttribute.GetBaseType(System.Reflection.FieldInfo)">
            <summary>
            It returns the base type of constraints.
            </summary>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>The base type of constraints</returns>
        </member>
        <member name="M:Arbor.ClassUnityObjectAttribute.IsConstraintSatisfied(System.Type,System.Reflection.FieldInfo)">
            <summary>
            Whether the constraint is satisfied is judged.
            </summary>
            <param name="type">Determining type</param>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>Returns true if the constraint is satisfied.</returns>
        </member>
        <member name="T:Arbor.ClassComponentAttribute">
            <summary>
            Attribute to restrict to classes inherited from UnityEngine.Component for fields.
            </summary>
            <remarks>
            Except for classes inherited from NodeBehaviour. <br/>
            Available classes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.ClassTypeReference"/></description></item>
            <item><description><see cref="T:Arbor.AnyParameterReference"/></description></item>
            <item><description><see cref="T:Arbor.ComponentParameterReference"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotAny"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotComponent"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotUnityObject"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Arbor.ClassComponentAttribute.GetBaseType(System.Reflection.FieldInfo)">
            <summary>
            It returns the base type of constraints.
            </summary>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>The base type of constraints</returns>
        </member>
        <member name="M:Arbor.ClassComponentAttribute.IsConstraintSatisfied(System.Type,System.Reflection.FieldInfo)">
            <summary>
            Whether the constraint is satisfied is judged.
            </summary>
            <param name="type">Determining type</param>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>Returns true if the constraint is satisfied.</returns>
        </member>
        <member name="T:Arbor.ClassScriptableObjectAttribute">
            <summary>
            Attribute to restrict to classes inherited from UnityEngine.ScriptableObject for fields.
            </summary>
            <remarks>
            Available classes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.ClassTypeReference"/></description></item>
            <item><description><see cref="T:Arbor.AnyParameterReference"/></description></item>
            <item><description><see cref="T:Arbor.ComponentParameterReference"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotAny"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotComponent"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotUnityObject"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Arbor.ClassScriptableObjectAttribute.GetBaseType(System.Reflection.FieldInfo)">
            <summary>
            It returns the base type of constraints.
            </summary>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>The base type of constraints</returns>
        </member>
        <member name="M:Arbor.ClassScriptableObjectAttribute.IsConstraintSatisfied(System.Type,System.Reflection.FieldInfo)">
            <summary>
            Whether the constraint is satisfied is judged.
            </summary>
            <param name="type">Determining type</param>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>Returns true if the constraint is satisfied.</returns>
        </member>
        <member name="T:Arbor.ClassGenericArgumentAttribute">
            <summary>
            Attribute to restrict to field only for types specified as generic arguments.
            </summary>
            <remarks>
            Available classes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.ClassTypeReference"/></description></item>
            <item><description><see cref="T:Arbor.AnyParameterReference"/></description></item>
            <item><description><see cref="T:Arbor.ComponentParameterReference"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotAny"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotComponent"/></description></item>
            <item><description><see cref="T:Arbor.InputSlotUnityObject"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Arbor.ClassGenericArgumentAttribute.#ctor(System.Int32)">
            <summary>
            Create a ClassExtendsAttribute with a specified type.
            </summary>
            <param name="genericArgumentIndex">Index of generic argument</param>
        </member>
        <member name="M:Arbor.ClassGenericArgumentAttribute.GetBaseType(System.Reflection.FieldInfo)">
            <summary>
            It returns the base type of constraints.
            </summary>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>The base type of constraints</returns>
        </member>
        <member name="M:Arbor.ClassGenericArgumentAttribute.IsConstraintSatisfied(System.Type,System.Reflection.FieldInfo)">
            <summary>
            Whether the constraint is satisfied is judged.
            </summary>
            <param name="type">Determining type</param>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>Returns true if the constraint is satisfied.</returns>
        </member>
        <member name="T:Arbor.ClassEnumFieldConstraint">
            <summary>
            Attribute to restrict to enum types only for fields.
            </summary>
        </member>
        <member name="M:Arbor.ClassEnumFieldConstraint.GetTypeName(System.Reflection.FieldInfo)">
            <summary>
            Returns the type name of the constraint.
            </summary>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>Type name of constraint</returns>
        </member>
        <member name="M:Arbor.ClassEnumFieldConstraint.IsConstraintSatisfied(System.Type,System.Reflection.FieldInfo)">
            <summary>
            Whether the constraint is satisfied is judged.
            </summary>
            <param name="type">Determining type</param>
            <param name="fieldInfo">FieldInfo with this attribute specified</param>
            <returns>Returns true if the constraint is satisfied.</returns>
        </member>
        <member name="T:Arbor.ClassTypeReference">
            <summary>
            A reference class for serializable types.
            </summary>
            <remarks>To restrict selectable types from the Editor, specify an attribute that inherits ClassTypeConstraintAttribute.</remarks>
        </member>
        <member name="P:Arbor.ClassTypeReference.type">
            <summary>
            Reference type
            </summary>
        </member>
        <member name="M:Arbor.ClassTypeReference.#ctor">
            <summary>
            Create a ClassTypeReference without specifying anything.
            </summary>
        </member>
        <member name="M:Arbor.ClassTypeReference.#ctor(System.Type)">
            <summary>
            To create a ClassTypeReference specify the Type.
            </summary>
        </member>
        <member name="M:Arbor.ClassTypeReference.IsAssignableFrom(System.Type)">
            <summary>
            It is judged whether or not it is assignable type.
            </summary>
            <param name="type">Determining type</param>
            <returns>Returns true if it is an assignable type.</returns>
        </member>
        <member name="M:Arbor.ClassTypeReference.op_Equality(Arbor.ClassTypeReference,System.Type)">
            <summary>
            Returns whether ClassTypeReference is equal to Type.
            </summary>
            <param name="typeRef">Value of ClassTypeReference</param>
            <param name="type">Type value</param>
            <returns>Returns true if they are equal.</returns>
        </member>
        <member name="M:Arbor.ClassTypeReference.op_Inequality(Arbor.ClassTypeReference,System.Type)">
            <summary>
            Returns whether ClassTypeReference and Type are not equal.
            </summary>
            <param name="typeRef">Value of ClassTypeReference</param>
            <param name="type">Type value</param>
            <returns>Returns true if it is not equal.</returns>
        </member>
        <member name="M:Arbor.ClassTypeReference.op_Equality(System.Type,Arbor.ClassTypeReference)">
            <summary>
            Returns whether ClassTypeReference is equal to Type.
            </summary>
            <param name="type">Type value</param>
            <param name="typeRef">Value of ClassTypeReference</param>
            <returns>Returns true if they are equal.</returns>
        </member>
        <member name="M:Arbor.ClassTypeReference.op_Inequality(System.Type,Arbor.ClassTypeReference)">
            <summary>
            Returns whether ClassTypeReference and Type are not equal.
            </summary>
            <param name="type">Type value</param>
            <param name="typeRef">Value of ClassTypeReference</param>
            <returns>Returns true if it is not equal.</returns>
        </member>
        <member name="M:Arbor.ClassTypeReference.Equals(Arbor.ClassTypeReference)">
            <summary>
            Returns whether this is equal to ClassTypeReference.
            </summary>
            <param name="typeRef">Value of ClassTypeReference</param>
            <returns>Returns true if they are equal.</returns>
        </member>
        <member name="M:Arbor.ClassTypeReference.Equals(System.Type)">
            <summary>
            Returns whether this is equal to Type.
            </summary>
            <param name="type">Type value</param>
            <returns>Returns true if they are equal.</returns>
        </member>
        <member name="M:Arbor.ClassTypeReference.Equals(System.Object)">
            <summary>
            Returns whether this is equal to object.
            </summary>
            <param name="obj">object value</param>
            <returns>Returns true if they are equal.</returns>
        </member>
        <member name="M:Arbor.ClassTypeReference.GetHashCode">
            <summary>
            Get a hash code.
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:Arbor.ClassTypeReference.op_Implicit(Arbor.ClassTypeReference)~System.Type">
            <summary>
            Cast from ClassTypeReference to Type.
            </summary>
            <param name="typeRef">Value of ClassTypeReference</param>
        </member>
        <member name="M:Arbor.ClassTypeReference.op_Implicit(System.Type)~Arbor.ClassTypeReference">
            <summary>
            Cast from Type to ClassTypeReference.
            </summary>
            <param name="type">Value of Type</param>
        </member>
        <member name="M:Arbor.ClassTypeReference.ToString">
            <summary>
            Convert to a string.
            </summary>
            <returns>Converted string</returns>
        </member>
        <member name="M:Arbor.ClassTypeReference.TidyAssemblyTypeName(System.Type)">
            <summary>
            Convert Type to a serializable string.
            </summary>
            <param name="type">Type value</param>
            <returns>Serializable string</returns>
        </member>
        <member name="M:Arbor.ClassTypeReference.GetAssemblyType(System.String)">
            <summary>
            Get System.Type from string.
            </summary>
            <param name="assemblyTypeName">Type name</param>
            <returns>System.Type. If assemblyTypeName is empty or null, it returns null.</returns>
        </member>
        <member name="T:Arbor.CommentNode">
            <summary>
            Class that represents a comment
            </summary>
        </member>
        <member name="P:Arbor.CommentNode.commentID">
            <summary>
            Gets the comment identifier.
            </summary>
        </member>
        <member name="F:Arbor.CommentNode.comment">
            <summary>
            Comment string.
            </summary>
        </member>
        <member name="M:Arbor.CommentNode.#ctor(Arbor.NodeGraph,System.Int32)">
            <summary>
            CommentNode constructor
            </summary>
            <param name="nodeGraph">NodeGraph with this node</param>
            <param name="nodeID">Node ID</param>
            <remarks>
            Please use the <see cref = "M:Arbor.NodeGraph.CreateComment" /> comment node creating.
            </remarks>
        </member>
        <member name="T:Arbor.ComponentUtility">
            <summary>
            Component utility class for Editor
            </summary>
        </member>
        <member name="T:Arbor.ComponentUtility.DelayCallBack">
            <summary>
            Delegate of delayed invoked method
            </summary>
        </member>
        <member name="F:Arbor.ComponentUtility.editorProcessor">
            <summary>
            Component processor in Editor
            </summary>
        </member>
        <member name="F:Arbor.ComponentUtility.useEditorProcessor">
            <summary>
            Flag using editorProcessor.
            </summary>
        </member>
        <member name="M:Arbor.ComponentUtility.AddComponent(UnityEngine.GameObject,System.Type)">
            <summary>
            Add component.
            </summary>
            <param name="gameObject">GameObject</param>
            <param name="type">Component type</param>
            <returns>Component</returns>
        </member>
        <member name="M:Arbor.ComponentUtility.AddComponent``1(UnityEngine.GameObject)">
            <summary>
            Add component.
            </summary>
            <typeparam name="Type">Component type</typeparam>
            <param name="gameObject">GameObject</param>
            <returns>Component</returns>
        </member>
        <member name="M:Arbor.ComponentUtility.Destroy(UnityEngine.Object)">
            <summary>
            Destroy object.
            </summary>
            <param name="objectToUndo">Object</param>
        </member>
        <member name="M:Arbor.ComponentUtility.RecordObject(UnityEngine.Object,System.String)">
            <summary>
            Record object. Valid only in Editor.
            </summary>
            <param name="objectToUndo">Object</param>
            <param name="name">Name</param>
        </member>
        <member name="M:Arbor.ComponentUtility.RecordObjects(UnityEngine.Object[],System.String)">
            <summary>
            Records object. Valid only in Editor.
            </summary>
            <param name="objs">Objects</param>
            <param name="name">Name</param>
        </member>
        <member name="M:Arbor.ComponentUtility.RegisterCompleteObjectUndo(UnityEngine.Object,System.String)">
            <summary>
            Register Object in Undo. Valid only in Editor.
            </summary>
            <param name="objectToUndo">Object</param>
            <param name="name">Name</param>
        </member>
        <member name="M:Arbor.ComponentUtility.SetDirty(UnityEngine.Object)">
            <summary>
            Marks an Object as dirty. Valid only in Editor.
            </summary>
            <param name="obj">Object</param>
        </member>
        <member name="M:Arbor.ComponentUtility.MoveBehaviour(Arbor.Node,Arbor.NodeBehaviour)">
            <summary>
            Move behavior to node. Valid only in Editor.
            </summary>
            <param name="node">Moving destination node</param>
            <param name="behaviour">Moving NodeBehaviour</param>
        </member>
        <member name="M:Arbor.ComponentUtility.MoveVariable(Arbor.Parameter,Arbor.VariableBase)">
            <summary>
            Move variable to parameter. Valid only in Editor.
            </summary>
            <param name="parameter">Moving destination Parameter</param>
            <param name="variable">Moving VariableBase</param>
        </member>
        <member name="M:Arbor.ComponentUtility.RefreshNodeGraph(Arbor.NodeGraph)">
            <summary>
            Refresh NodeGraph. Valid only in Editor.
            </summary>
            <param name="nodeGraph">NodeGraph</param>
        </member>
        <member name="M:Arbor.ComponentUtility.IsValidObject(UnityEngine.Object)">
            <summary>
            Check if Object is valid.
            </summary>
            <param name="obj">Object</param>
        </member>
        <member name="M:Arbor.ComponentUtility.DelayDestroy(UnityEngine.Object)">
            <summary>
            Delay Destroy. Delayed only in Editor.
            </summary>
            <param name="obj">Object</param>
        </member>
        <member name="M:Arbor.ComponentUtility.DelayCall(Arbor.ComponentUtility.DelayCallBack)">
            <summary>
            Delay call. Delayed only in Editor.
            </summary>
            <param name="delayCall">Method to call</param>
        </member>
        <member name="T:Arbor.ConstantMultilineAttribute">
            <summary>
            Display multiple lines when the type of <see cref="T:Arbor.FlexibleString"/> is Constant.
            </summary>
        </member>
        <member name="T:Arbor.ConstantRangeAttribute">
            <summary>
            Limit the value range when <see cref = "T:Arbor.FlexibleInt" /> or <see cref = "T:Arbor.FlexibleFloat" /> type is Constant.
            </summary>
        </member>
        <member name="F:Arbor.ConstantRangeAttribute.min">
            <summary>
            Min value
            </summary>
        </member>
        <member name="F:Arbor.ConstantRangeAttribute.max">
            <summary>
            Max value
            </summary>
        </member>
        <member name="M:Arbor.ConstantRangeAttribute.#ctor(System.Single,System.Single)">
            <summary>
            Limit the value range when <see cref = "T:Arbor.FlexibleInt" /> or <see cref = "T:Arbor.FlexibleFloat" /> type is Constant.
            </summary>
            <param name="min">Min Value</param>
            <param name="max">Max Value</param>
        </member>
        <member name="T:Arbor.DataBranch">
            <summary>
            Class that connects DataSlot.
            </summary>
        </member>
        <member name="F:Arbor.DataBranch.branchID">
            <summary>
            ID of branch.
            </summary>
        </member>
        <member name="F:Arbor.DataBranch.enabled">
            <summary>
            Whether to draw. For the editor.
            </summary>
        </member>
        <member name="F:Arbor.DataBranch.inBehaviour">
            <summary>
            Input side Behaviour
            </summary>
        </member>
        <member name="F:Arbor.DataBranch.inNodeID">
            <summary>
            Input side nodeID
            </summary>
        </member>
        <member name="F:Arbor.DataBranch.outBehaviour">
            <summary>
            Output side Behaviour
            </summary>
        </member>
        <member name="F:Arbor.DataBranch.outNodeID">
            <summary>
            Output side nodeID
            </summary>
        </member>
        <member name="F:Arbor.DataBranch.lineBezier">
            <summary>
            Bezier curve of the line to be connected. For editor
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.value">
            <summary>
            get set the value.
            When connecting to the output slot of Calculator, update it as necessary and obtain it.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.currentValue">
            <summary>
            Get the current value.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.isUsed">
            <summary>
            Gets whether or not a value is used.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.outputSlotColor">
            <summary>
            For editor
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.inputSlotColor">
            <summary>
            For editor
            </summary>
        </member>
        <member name="F:Arbor.DataBranch.showDataValue">
            <summary>
            Gets whether or not a value is visible.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.isVisible">
            <summary>
            Gets whether or not a value is visible.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.updatedTime">
            <summary>
            Time that does not depend on timeScale when value is updated.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.outputSlotField">
            <summary>
            Get DataSlotField of output slot.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.outputSlot">
            <summary>
            Get the output slot.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.outputSlotFieldInfo">
            <summary>
            Get the FieldInfo of the output slot.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.outputType">
            <summary>
            Output type.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.isValidOutputSlot">
            <summary>
            Returns whether the output slot is valid.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.inputSlotField">
            <summary>
            Get the FieldInfo of the input slot.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.inputSlot">
            <summary>
            Get the input slot.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.inputSlotFieldInfo">
            <summary>
            Get the FieldInfo of the input slot.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.inputType">
            <summary>
            Input type.
            </summary>
        </member>
        <member name="P:Arbor.DataBranch.isValidInputSlot">
            <summary>
            Returns whether the input slot is valid.
            </summary>
        </member>
        <member name="M:Arbor.DataBranch.SetBehaviour(System.Int32,UnityEngine.Object,System.Int32,UnityEngine.Object)">
            <summary>
            Change Behavior.
            </summary>
        </member>
        <member name="M:Arbor.DataBranch.SetDirtySlotField">
            <summary>
            Mark slot field as dirty
            </summary>
        </member>
        <member name="T:Arbor.DataBranchRerouteNode">
            <summary>
            Reroute node of DataBranch.
            </summary>
        </member>
        <member name="F:Arbor.DataBranchRerouteNode.link">
            <summary>
            Reroute slot
            </summary>
        </member>
        <member name="F:Arbor.DataBranchRerouteNode.direction">
            <summary>
            Direction of line
            </summary>
        </member>
        <member name="P:Arbor.DataBranchRerouteNode.slotField">
            <summary>
            link's DataSlotField
            </summary>
        </member>
        <member name="M:Arbor.DataBranchRerouteNode.#ctor(Arbor.NodeGraph,System.Int32,System.Type)">
            <summary>
            DataBranchRerouteNode constructor
            </summary>
            <param name="nodeGraph">NodeGraph with this node</param>
            <param name="nodeID">Node ID</param>
            <param name="type">Value type</param>
            <remarks>
            Please use the <see cref = "M:Arbor.NodeGraph.CreateDataBranchRerouteNode(UnityEngine.Vector2,System.Type)" /> DataBranchRerouteNode creating.
            </remarks>
        </member>
        <member name="T:Arbor.DataBranchRerouteNodeList">
            <summary>
            DataBranchRerouteNode List
            </summary>
        </member>
        <member name="T:Arbor.DataSlot">
            <summary>
            Slot for connecting a calculator node.
            </summary>
        </member>
        <member name="P:Arbor.DataSlot.slotType">
            <summary>
            Slot type
            </summary>
        </member>
        <member name="F:Arbor.DataSlot.nodeGraph">
            <summary>
            State machine slot belongs
            </summary>
        </member>
        <member name="F:Arbor.DataSlot.position">
            <summary>
            Position on ArborEditor of slot(Editor Only)
            </summary>
        </member>
        <member name="P:Arbor.DataSlot.dataType">
            <summary>
            The type of data stored in the slot
            </summary>
        </member>
        <member name="M:Arbor.DataSlot.Disconnect">
            <summary>
            Disconnect the connection.
            </summary>
        </member>
        <member name="T:Arbor.DataSlotField">
            <summary>
            Field information of DataSlot
            </summary>
        </member>
        <member name="P:Arbor.DataSlotField.slot">
            <summary>
            DataSlot
            </summary>
        </member>
        <member name="P:Arbor.DataSlotField.fieldInfo">
            <summary>
            FieldInfo
            </summary>
        </member>
        <member name="F:Arbor.DataSlotField.overrideConstraint">
            <summary>
            override ClassConstraintInfo
            </summary>
        </member>
        <member name="M:Arbor.DataSlotField.GetConstraint">
            <summary>
            Return information on type constraints.
            </summary>
            <returns>Type constraint information</returns>
        </member>
        <member name="P:Arbor.DataSlotField.connectableType">
            <summary>
            Connectable type
            </summary>
        </member>
        <member name="P:Arbor.DataSlotField.connectableTypeName">
            <summary>
            Connectable type name
            </summary>
        </member>
        <member name="P:Arbor.DataSlotField.isVisible">
            <summary>
            For Editor.
            </summary>
        </member>
        <member name="M:Arbor.DataSlotField.SetVisible">
            <summary>
            For Editor.
            </summary>
        </member>
        <member name="M:Arbor.DataSlotField.ClearVisible">
            <summary>
            For Editor.
            </summary>
        </member>
        <member name="M:Arbor.DataSlotField.#ctor(Arbor.DataSlot,System.Reflection.FieldInfo)">
            <summary>
            DataSlotField constructor
            </summary>
            <param name="slot">DataSlot</param>
            <param name="fieldInfo">FieldInfo</param>
        </member>
        <member name="M:Arbor.DataSlotField.IsConnectable(Arbor.DataSlotField)">
            <summary>
            It is judged whether connection is possible.
            </summary>
            <param name="slotField">Slot to determine</param>
            <returns>Returns true if connectable, false otherwise.</returns>
        </member>
        <member name="T:Arbor.IInputSlot">
            <summary>
            Interface of input DataSlot.
            </summary>
        </member>
        <member name="M:Arbor.IInputSlot.SetInputBranch(Arbor.DataBranch)">
            <summary>
            Set DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
        </member>
        <member name="M:Arbor.IInputSlot.RemoveInputBranch(Arbor.DataBranch)">
            <summary>
            Remove DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
        </member>
        <member name="M:Arbor.IInputSlot.GetInputBranch">
            <summary>
            Get DataBranch.
            </summary>
            <returns>DataBranch</returns>
        </member>
        <member name="M:Arbor.IInputSlot.IsConnectedInput(Arbor.DataBranch)">
            <summary>
            It judges whether it is connected with DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
            <returns>True if connected, false otherwise.</returns>
        </member>
        <member name="T:Arbor.InputSlotBase">
            <summary>
            Input slot
            </summary>
        </member>
        <member name="F:Arbor.InputSlotBase.branchID">
            <summary>
            Branch ID
            </summary>
        </member>
        <member name="P:Arbor.InputSlotBase.slotType">
            <summary>
            Slot type
            </summary>
        </member>
        <member name="P:Arbor.InputSlotBase.branch">
            <summary>
            Get branch
            </summary>
        </member>
        <member name="P:Arbor.InputSlotBase.isUsed">
            <summary>
            Gets whether or not a value is used.
            </summary>
        </member>
        <member name="P:Arbor.InputSlotBase.updatedTime">
            <summary>
            Time that does not depend on timeScale when value is updated.
            </summary>
        </member>
        <member name="M:Arbor.InputSlotBase.SetInputBranch(Arbor.DataBranch)">
            <summary>
            Set DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
        </member>
        <member name="M:Arbor.InputSlotBase.RemoveInputBranch(Arbor.DataBranch)">
            <summary>
            Remove DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
        </member>
        <member name="M:Arbor.InputSlotBase.GetInputBranch">
            <summary>
            Get DataBranch.
            </summary>
            <returns>DataBranch</returns>
        </member>
        <member name="M:Arbor.InputSlotBase.IsConnectedInput(Arbor.DataBranch)">
            <summary>
            It judges whether it is connected with DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
            <returns>True if connected, false otherwise.</returns>
        </member>
        <member name="M:Arbor.InputSlotBase.Disconnect">
            <summary>
            Disconnect the connection.
            </summary>
        </member>
        <member name="T:Arbor.InputSlot`1">
            <summary>
            Generic class of the input slot
            </summary>
            <typeparam name="T">Type of data</typeparam>
        </member>
        <member name="P:Arbor.InputSlot`1.dataType">
            <summary>
            The type of data stored in the slot
            </summary>
        </member>
        <member name="M:Arbor.InputSlot`1.GetValue(`0@)">
            <summary>
            Get the value
            </summary>
            <param name="value">The value you get</param>
            <returns>Whether the branch is connected.</returns>
        </member>
        <member name="T:Arbor.InputSlotAny">
            <summary>
            Input slot class specifying type
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.ClassTypeConstraintAttribute" /></description></item>
            <item><description><see cref="T:Arbor.SlotTypeAttribute" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Arbor.InputSlotAny.dataType">
            <summary>
            The type of data stored in the slot
            </summary>
        </member>
        <member name="M:Arbor.InputSlotAny.#ctor">
            <summary>
            InputSlotAny default constructor
            </summary>
        </member>
        <member name="M:Arbor.InputSlotAny.#ctor(System.Type)">
            <summary>
            InputSlotAny constructor
            </summary>
            <param name="targetType">Input type</param>
        </member>
        <member name="M:Arbor.InputSlotAny.GetValue(System.Object@)">
            <summary>
            Get the value
            </summary>
            <param name="value">The value you get</param>
            <returns>Whether the branch is connected.</returns>
        </member>
        <member name="M:Arbor.InputSlotAny.GetValue``1(``0@)">
            <summary>
            Get the value
            </summary>
            <param name="value">The value you get</param>
            <returns>Whether the branch is connected.</returns>
        </member>
        <member name="T:Arbor.IOutputSlot">
            <summary>
            Interface of output DataSlot.
            </summary>
        </member>
        <member name="M:Arbor.IOutputSlot.AddOutputBranch(Arbor.DataBranch)">
            <summary>
            Addition of DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
        </member>
        <member name="M:Arbor.IOutputSlot.RemoveOutputBranch(Arbor.DataBranch)">
            <summary>
            Remove DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
        </member>
        <member name="M:Arbor.IOutputSlot.GetOutputBranchCount">
            <summary>
            Get count of DataBranch.
            </summary>
            <returns>Count of DataBranch</returns>
        </member>
        <member name="M:Arbor.IOutputSlot.GetOutputBranch(System.Int32)">
            <summary>
            Get DataBranch.
            </summary>
            <param name="index">Index</param>
            <returns>DataBranch</returns>
        </member>
        <member name="M:Arbor.IOutputSlot.IsConnectedOutput(Arbor.DataBranch)">
            <summary>
            It judges whether it is connected with DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
            <returns>True if connected, false otherwise.</returns>
        </member>
        <member name="T:Arbor.OutputSlotBase">
            <summary>
            Output slot
            </summary>
        </member>
        <member name="F:Arbor.OutputSlotBase.branchIDs">
            <summary>
            List of the destination branch
            </summary>
        </member>
        <member name="P:Arbor.OutputSlotBase.slotType">
            <summary>
            Slot type
            </summary>
        </member>
        <member name="M:Arbor.OutputSlotBase.AddOutputBranch(Arbor.DataBranch)">
            <summary>
            Addition of DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
        </member>
        <member name="M:Arbor.OutputSlotBase.RemoveOutputBranch(Arbor.DataBranch)">
            <summary>
            Remove DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
        </member>
        <member name="M:Arbor.OutputSlotBase.GetOutputBranchCount">
            <summary>
            Get count of DataBranch.
            </summary>
            <returns>Count of DataBranch</returns>
        </member>
        <member name="M:Arbor.OutputSlotBase.GetOutputBranch(System.Int32)">
            <summary>
            Get DataBranch.
            </summary>
            <param name="index">Index</param>
            <returns>DataBranch</returns>
        </member>
        <member name="M:Arbor.OutputSlotBase.IsConnectedOutput(Arbor.DataBranch)">
            <summary>
            It judges whether it is connected with DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
            <returns>True if connected, false otherwise.</returns>
        </member>
        <member name="M:Arbor.OutputSlotBase.Disconnect">
            <summary>
            Disconnect the connection.
            </summary>
        </member>
        <member name="T:Arbor.OutputSlot`1">
            <summary>
            Generic class of the output slot
            </summary>
            <typeparam name="T">Type of data</typeparam>
        </member>
        <member name="P:Arbor.OutputSlot`1.dataType">
            <summary>
            The type of data stored in the slot
            </summary>
        </member>
        <member name="M:Arbor.OutputSlot`1.SetValue(`0)">
            <summary>
            Set the value
            </summary>
            <param name="value">The value to be set</param>
        </member>
        <member name="T:Arbor.InputSlotTypable">
            <summary>
            Input slot class specifying type
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.HideSlotFields" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Arbor.InputSlotTypable.dataType">
            <summary>
            The type of data stored in the slot
            </summary>
        </member>
        <member name="M:Arbor.InputSlotTypable.#ctor">
            <summary>
            InputSlotTypable constructor
            </summary>
        </member>
        <member name="M:Arbor.InputSlotTypable.#ctor(System.Type)">
            <summary>
            InputSlotTypable constructor
            </summary>
            <param name="type">Data type to be stored in the slot</param>
        </member>
        <member name="M:Arbor.InputSlotTypable.GetValue(System.Object@)">
            <summary>
            Get the value
            </summary>
            <param name="value">The value you get</param>
            <returns>Whether the branch is connected.</returns>
        </member>
        <member name="T:Arbor.OutputSlotTypable">
            <summary>
            Output slot class specifying type
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.HideSlotFields" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Arbor.OutputSlotTypable.dataType">
            <summary>
            The type of data stored in the slot
            </summary>
        </member>
        <member name="M:Arbor.OutputSlotTypable.#ctor">
            <summary>
            OutputSlotTypable constructor
            </summary>
        </member>
        <member name="M:Arbor.OutputSlotTypable.#ctor(System.Type)">
            <summary>
            OutputSlotTypable constructor
            </summary>
            <param name="type">Data type to be stored in the slot</param>
        </member>
        <member name="M:Arbor.OutputSlotTypable.SetValue(System.Object)">
            <summary>
            Set the value
            </summary>
            <param name="value">The value to be set</param>
        </member>
        <member name="T:Arbor.OutputSlotAny">
            <summary>
            Output slot class outputting any type
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.SlotTypeAttribute" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Arbor.OutputSlotAny.dataType">
            <summary>
            The type of data stored in the slot
            </summary>
        </member>
        <member name="M:Arbor.OutputSlotAny.#ctor">
            <summary>
            OutputSlotAny default constructor
            </summary>
        </member>
        <member name="M:Arbor.OutputSlotAny.#ctor(System.Type)">
            <summary>
            OutputSlotAny constructor
            </summary>
            <param name="targetType">Output type</param>
        </member>
        <member name="M:Arbor.OutputSlotAny.SetValue(System.Object)">
            <summary>
            Set the value
            </summary>
            <param name="value">The value to be set</param>
        </member>
        <member name="T:Arbor.RerouteSlot">
            <summary>
            Slot used for midpoint of DataBranch.
            </summary>
        </member>
        <member name="F:Arbor.RerouteSlot.inputBranchID">
            <summary>
            Input branch ID
            </summary>
        </member>
        <member name="F:Arbor.RerouteSlot.outputBranchIDs">
            <summary>
            Output branch ID
            </summary>
        </member>
        <member name="F:Arbor.RerouteSlot.type">
            <summary>
            Connectable value type
            </summary>
        </member>
        <member name="P:Arbor.RerouteSlot.slotType">
            <summary>
            Slot type
            </summary>
        </member>
        <member name="P:Arbor.RerouteSlot.dataType">
            <summary>
            The type of data stored in the slot
            </summary>
        </member>
        <member name="M:Arbor.RerouteSlot.SetInputBranch(Arbor.DataBranch)">
            <summary>
            Set DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
        </member>
        <member name="M:Arbor.RerouteSlot.RemoveInputBranch(Arbor.DataBranch)">
            <summary>
            Remove DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
        </member>
        <member name="M:Arbor.RerouteSlot.GetInputBranch">
            <summary>
            Get DataBranch.
            </summary>
            <returns>DataBranch</returns>
        </member>
        <member name="M:Arbor.RerouteSlot.IsConnectedInput(Arbor.DataBranch)">
            <summary>
            It judges whether it is connected with DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
            <returns>True if connected, false otherwise.</returns>
        </member>
        <member name="M:Arbor.RerouteSlot.AddOutputBranch(Arbor.DataBranch)">
            <summary>
            Addition of DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
        </member>
        <member name="M:Arbor.RerouteSlot.RemoveOutputBranch(Arbor.DataBranch)">
            <summary>
            Remove DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
        </member>
        <member name="M:Arbor.RerouteSlot.GetOutputBranchCount">
            <summary>
            Get count of DataBranch.
            </summary>
            <returns>Count of DataBranch</returns>
        </member>
        <member name="M:Arbor.RerouteSlot.GetOutputBranch(System.Int32)">
            <summary>
            Get DataBranch.
            </summary>
            <param name="index">Index</param>
            <returns>DataBranch</returns>
        </member>
        <member name="M:Arbor.RerouteSlot.IsConnectedOutput(Arbor.DataBranch)">
            <summary>
            It judges whether it is connected with DataBranch.
            </summary>
            <param name="branch">DataBranch</param>
            <returns>True if connected, false otherwise.</returns>
        </member>
        <member name="M:Arbor.RerouteSlot.Disconnect">
            <summary>
            Disconnect the connection.
            </summary>
        </member>
        <member name="T:Arbor.InputSlotInt">
            <summary>
            int type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotInt">
            <summary>
            int type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotLong">
            <summary>
            long type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotLong">
            <summary>
            long type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotFloat">
            <summary>
            float type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotFloat">
            <summary>
            float type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotBool">
            <summary>
            bool type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotBool">
            <summary>
            bool type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotString">
            <summary>
            string type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotString">
            <summary>
            string type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotGameObject">
            <summary>
            GameObject type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotGameObject">
            <summary>
            GameObject type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotVector2">
            <summary>
            Vector2 type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotVector2">
            <summary>
            Vector2 type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotVector3">
            <summary>
            Vector3 type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotVector3">
            <summary>
            Vector3 type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotQuaternion">
            <summary>
            Quaternion type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotQuaternion">
            <summary>
            Quaternion type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotRect">
            <summary>
            Rect type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotRect">
            <summary>
            Rect type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotBounds">
            <summary>
            Bounds type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotBounds">
            <summary>
            Bounds type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotColor">
            <summary>
            Color type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotColor">
            <summary>
            Color type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotUnityObject">
            <summary>
            UnityEngine.Object type of input slot
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.ClassTypeConstraintAttribute" /></description></item>
            <item><description><see cref="T:Arbor.SlotTypeAttribute" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Arbor.InputSlotUnityObject.GetValue``1">
            <summary>
            Get value.
            </summary>
            <typeparam name="T">Type of value to get.</typeparam>
            <returns>The value you got. If there is none, it returns null.</returns>
        </member>
        <member name="T:Arbor.OutputSlotUnityObject">
            <summary>
            UnityEngine.Object type of output slot
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.HideSlotFields" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Arbor.OutputSlotUnityObject.dataType">
            <summary>
            The type of data stored in the slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotComponent">
            <summary>
            Component type of input slot
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.ClassTypeConstraintAttribute" /></description></item>
            <item><description><see cref="T:Arbor.SlotTypeAttribute" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Arbor.InputSlotComponent.GetValue``1">
            <summary>
            Get value.
            </summary>
            <typeparam name="T">Type of value to get.</typeparam>
            <returns>The value you got. If there is none, it returns null.</returns>
        </member>
        <member name="T:Arbor.OutputSlotComponent">
            <summary>
            Component type of output slot
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.HideSlotFields" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Arbor.OutputSlotComponent.dataType">
            <summary>
            The type of data stored in the slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotTransform">
            <summary>
            Transform type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotTransform">
            <summary>
            Transform type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotRectTransform">
            <summary>
            RectTransform type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotRectTransform">
            <summary>
            RectTransform type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotRigidbody">
            <summary>
            Rigidbody type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotRigidbody">
            <summary>
            Rigidbody type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotRigidbody2D">
            <summary>
            Rigidbody2D type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotRigidbody2D">
            <summary>
            Rigidbody2D type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotCollider">
            <summary>
            Collider type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotCollider">
            <summary>
            Collider type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotCollider2D">
            <summary>
            Collider2D type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotCollider2D">
            <summary>
            Collider2D type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotCollision">
            <summary>
            Collision type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotCollision">
            <summary>
            Collision type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotCollision2D">
            <summary>
            Collision2D type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotCollision2D">
            <summary>
            Collision2D type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotRaycastHit">
            <summary>
            RaycastHit type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotRaycastHit">
            <summary>
            RaycastHit type of output slot
            </summary>
        </member>
        <member name="T:Arbor.InputSlotRaycastHit2D">
            <summary>
            RaycastHit2D type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotRaycastHit2D">
            <summary>
            RaycastHit2D type of output slot
            </summary>
        </member>
        <member name="T:Arbor.DebugInfiniteLoopSettings">
            <summary>
            Debug setting of infinite loop
            </summary>
        </member>
        <member name="F:Arbor.DebugInfiniteLoopSettings.maxLoopCount">
            <summary>
            Maximum loop count
            </summary>
        </member>
        <member name="F:Arbor.DebugInfiniteLoopSettings.enableLogging">
            <summary>
            Enable logging. Log output when the loop count is over maxLoopCount.
            </summary>
        </member>
        <member name="F:Arbor.DebugInfiniteLoopSettings.enableBreak">
            <summary>
            Enable Break. Debug.Break when the loop count is over maxLoopCount.
            </summary>
        </member>
        <member name="T:Arbor.DynamicReflection.DynamicField">
            <summary>
            A class that accesses Field directly.
            </summary>
            <remarks>In AOT and IL2CPP environments, it is access by Reflection.</remarks>
        </member>
        <member name="P:Arbor.DynamicReflection.DynamicField.fieldInfo">
            <summary>
            Referencing FieldInfo
            </summary>
        </member>
        <member name="M:Arbor.DynamicReflection.DynamicField.GetValue(System.Object)">
            <summary>
            Returns the value of the field.
            </summary>
            <param name="instance">An instance that has a field</param>
            <returns>Field value</returns>
        </member>
        <member name="M:Arbor.DynamicReflection.DynamicField.SetValue(System.Object,System.Object)">
            <summary>
            Set the value of the field.
            </summary>
            <param name="instance">An instance that has a field</param>
            <param name="value">Field value</param>
        </member>
        <member name="M:Arbor.DynamicReflection.DynamicField.GetField(System.Reflection.FieldInfo)">
            <summary>
            Returns DynamicField.
            </summary>
            <param name="fieldInfo">Reference FieldInfo</param>
            <returns>DynamicField referencing the specified FieldInfo</returns>
        </member>
        <member name="T:Arbor.DynamicReflection.DynamicMethod">
            <summary>
            A class that accesses Method directly.
            </summary>
            <remarks>In AOT and IL2CPP environments, it is access by Reflection.</remarks>
        </member>
        <member name="P:Arbor.DynamicReflection.DynamicMethod.methodInfo">
            <summary>
            Referencing MethodInfo
            </summary>
        </member>
        <member name="M:Arbor.DynamicReflection.DynamicMethod.Invoke(System.Object,System.Object[])">
            <summary>
            Call method
            </summary>
            <param name="instance">An instance that has a method</param>
            <param name="arguments">Argument list</param>
            <returns>Method return value</returns>
        </member>
        <member name="M:Arbor.DynamicReflection.DynamicMethod.GetMethod(System.Reflection.MethodInfo)">
            <summary>
            Returns DynamicMethod.
            </summary>
            <param name="methodInfo">Reference MethodInfo</param>
            <returns>DynamicMethod referencing the specified MethodInfo</returns>
        </member>
        <member name="T:Arbor.EachField`1">
            <summary>
            Find each serializable field
            </summary>
            <typeparam name="T">Type to find</typeparam>
        </member>
        <member name="T:Arbor.EachField`1.OnFind">
            <summary>
            Callback when found.
            </summary>
            <param name="value">find value</param>
        </member>
        <member name="T:Arbor.EachField`1.OnFindEx">
            <summary>
            Callback when found.
            </summary>
            <param name="value">find value</param>
            <param name="fieldInfo">FieldInfo of Value</param>
        </member>
        <member name="M:Arbor.EachField`1.GetFields(System.Type)">
            <summary>
            Get Fields
            </summary>
            <param name="type">Object type</param>
            <returns>Field enumerator</returns>
        </member>
        <member name="M:Arbor.EachField`1.Find(System.Object,System.Type,Arbor.EachField{`0}.OnFind)">
            <summary>
            Find the field.
            </summary>
            <param name="obj">Object</param>
            <param name="type">Type of object</param>
            <param name="onFind">Callback If you find</param>
        </member>
        <member name="M:Arbor.EachField`1.Find(System.Object,System.Type,Arbor.EachField{`0}.OnFindEx)">
            <summary>
            Find the field.
            </summary>
            <param name="obj">Object</param>
            <param name="type">Type of object</param>
            <param name="onFind">Callback If you find</param>
        </member>
        <member name="M:Arbor.EachField`1.ClearCache">
            <summary>
            Clear cache
            </summary>
        </member>
        <member name="T:Arbor.EnumFieldUtility">
            <summary>
            Utility class of FlexibleEnumAny or enum type Parameter
            </summary>
        </member>
        <member name="M:Arbor.EnumFieldUtility.IsEnum(System.Type)">
            <summary>
            Enum type check
            </summary>
            <param name="enumType">enum type</param>
            <returns>Return true if it is an enum type</returns>
        </member>
        <member name="T:Arbor.EulerAnglesAttribute">
            <summary>
            Attribute to edit Quaternion at Euler angles.
            </summary>
        </member>
        <member name="T:Arbor.Events.ArgumentAttributes">
            <summary>
            Attribute flag of argument
            </summary>
        </member>
        <member name="F:Arbor.Events.ArgumentAttributes.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Arbor.Events.ArgumentAttributes.Out">
            <summary>
            Output
            </summary>
        </member>
        <member name="T:Arbor.Events.ArborEvent">
            <summary>
            Persistent callbacks that can also set arguments in ArborEditor
            </summary>
        </member>
        <member name="P:Arbor.Events.ArborEvent.warningMessage">
            <summary>
            Returns a message if there is a warning on the method call.
            </summary>
        </member>
        <member name="M:Arbor.Events.ArborEvent.Invoke">
            <summary>
            Calling methods
            </summary>
        </member>
        <member name="T:Arbor.Events.ArborEventUtility">
            <summary>
            ArborEvent utility class
            </summary>
        </member>
        <member name="M:Arbor.Events.ArborEventUtility.GetMethodName(System.Reflection.MethodInfo)">
            <summary>
            Returns the method name.
            </summary>
            <param name="methodInfo">MethodInfo that returns method name</param>
            <returns>Method name</returns>
        </member>
        <member name="M:Arbor.Events.ArborEventUtility.GetParameterType(System.Type)">
            <summary>
            Returns the type of parameter.
            </summary>
            <param name="type">Type</param>
            <returns>Type of parameter</returns>
        </member>
        <member name="M:Arbor.Events.ArborEventUtility.IsSelectableMethod(System.Reflection.MethodInfo)">
            <summary>
            It is judged whether it is a selectable method.
            </summary>
            <param name="methodInfo">MethodInfo to determine</param>
            <returns>Returns true if it is selectable</returns>
        </member>
        <member name="M:Arbor.Events.ArborEventUtility.Cast(System.Object,System.Type)">
            <summary>
            Cast the object.
            </summary>
            <param name="obj">The object to cast</param>
            <param name="type">Casting type</param>
            <returns>Casted value</returns>
        </member>
        <member name="M:Arbor.Events.ArborEventUtility.GetDefault(System.Type)">
            <summary>
            Returns the default value of type.
            </summary>
            <param name="type">Default value type</param>
            <returns>Default value</returns>
        </member>
        <member name="T:Arbor.Events.HideEventAttribute">
            <summary>
            Attribute that hides the method in the selection popup of ArborEvent.
            </summary>
        </member>
        <member name="T:Arbor.Events.ParameterType">
            <summary>
            Types of argument types available for ArborEvent
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.Int">
            <summary>
            int type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.Long">
            <summary>
            long type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.Float">
            <summary>
            float type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.Bool">
            <summary>
            bool type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.String">
            <summary>
            string type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.Vector2">
            <summary>
            Vector2 type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.Vector3">
            <summary>
            Vector3 type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.Quaternion">
            <summary>
            Quaternion type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.Rect">
            <summary>
            Rect type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.Bounds">
            <summary>
            Bounds type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.Color">
            <summary>
            Color type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.GameObject">
            <summary>
            GameObject type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.Component">
            <summary>
            Component type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.Enum">
            <summary>
            enum type
            </summary>
        </member>
        <member name="F:Arbor.Events.ParameterType.Slot">
            <summary>
            Data slot
            </summary>
            <remarks>Used when the ArborEventUtility.GetParameterType method returns Unknown.</remarks>
        </member>
        <member name="F:Arbor.Events.ParameterType.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="T:Arbor.Events.ShowEventAttribute">
            <summary>
            Attributes to be displayed in selection popup even argument methods that can not be used for ArborEvent
            </summary>
            <remarks>See <see cref="T:Arbor.Events.ParameterType" /> for available argument types.</remarks>
        </member>
        <member name="T:Arbor.FixedImmediateTransition">
            <summary>
            Setting the StateLink is in a state of fixing an immediate transition flags.
            This specified separately that it also specify the immediate argument of Transition method with.
            </summary>
        </member>
        <member name="P:Arbor.FixedImmediateTransition.immediate">
            <summary>
            immediate flag.
            </summary>
        </member>
        <member name="M:Arbor.FixedImmediateTransition.#ctor(System.Boolean)">
            <summary>
            FixedImmediateTransition constructor
            </summary>
            <param name="immediate">Immediate flag</param>
        </member>
        <member name="T:Arbor.FixedTransitionTiming">
            <summary>
            Setting the StateLink is in a state of fixing an immediate transition flags.
            This specified separately that it also specify the transitionTiming argument of Transition method with.
            </summary>
        </member>
        <member name="P:Arbor.FixedTransitionTiming.transitionTiming">
            <summary>
            Transition timing
            </summary>
        </member>
        <member name="M:Arbor.FixedTransitionTiming.#ctor(Arbor.TransitionTiming)">
            <summary>
            FixedTransitionTiming constructor
            </summary>
            <param name="transitionTiming">Transition timing</param>
        </member>
        <member name="T:Arbor.FlexibleBool">
            <summary>
            Class to handle a flexible bool type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleBool.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleBool.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleBool.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="M:Arbor.FlexibleBool.#ctor">
            <summary>
            FlexibleBool default constructor.
            </summary>
        </member>
        <member name="M:Arbor.FlexibleBool.#ctor(System.Boolean)">
            <summary>
            FlexibleBool default constructor.
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleBool.#ctor(Arbor.BoolParameterReference)">
            <summary>
            FlexibleBool default constructor.
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleBool.#ctor(System.Single)">
            <summary>
            FlexibleBool default constructor.
            </summary>
            <param name="probability">Probability</param>
        </member>
        <member name="M:Arbor.FlexibleBool.#ctor(Arbor.InputSlotBool)">
            <summary>
            FlexibleBool default constructor.
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleBool.op_Explicit(Arbor.FlexibleBool)~System.Boolean">
            <summary>
            Cast FlexibleBool to bool.
            </summary>
            <param name="flexible">FlexibleBool</param>
        </member>
        <member name="M:Arbor.FlexibleBool.op_Explicit(System.Boolean)~Arbor.FlexibleBool">
            <summary>
            Cast bool to FlexibleBool.
            </summary>
            <param name="value">bool</param>
        </member>
        <member name="T:Arbor.FlexibleBounds">
            <summary>
            Class to handle a flexible Bounds type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleBounds.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleBounds.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleBounds.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleBounds.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="M:Arbor.FlexibleBounds.#ctor">
            <summary>
            FlexibleBounds default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleBounds.#ctor(UnityEngine.Bounds)">
            <summary>
            FlexibleBounds constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleBounds.#ctor(Arbor.BoundsParameterReference)">
            <summary>
            FlexibleBounds constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleBounds.#ctor(Arbor.InputSlotBounds)">
            <summary>
            FlexibleBounds constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleBounds.op_Explicit(Arbor.FlexibleBounds)~UnityEngine.Bounds">
            <summary>
            Cast FlexibleBounds to Bounds.
            </summary>
            <param name="flexible">FlexibleBounds</param>
        </member>
        <member name="M:Arbor.FlexibleBounds.op_Explicit(UnityEngine.Bounds)~Arbor.FlexibleBounds">
            <summary>
            Cast Bounds to FlexibleBounds.
            </summary>
            <param name="value">Bounds</param>
        </member>
        <member name="T:Arbor.FlexibleColor">
            <summary>
            Class to handle a flexible Color type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleColor.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleColor.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleColor.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleColor.#ctor">
            <summary>
            FlexibleColor default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleColor.#ctor(UnityEngine.Color)">
            <summary>
            FlexibleColor constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleColor.#ctor(Arbor.ColorParameterReference)">
            <summary>
            FlexibleColor constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleColor.#ctor(Arbor.InputSlotColor)">
            <summary>
            FlexibleColor constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleColor.op_Explicit(Arbor.FlexibleColor)~UnityEngine.Color">
            <summary>
            Cast FlexibleColor to Color.
            </summary>
            <param name="flexible">FlexibleColor</param>
        </member>
        <member name="M:Arbor.FlexibleColor.op_Explicit(UnityEngine.Color)~Arbor.FlexibleColor">
            <summary>
            Cast Color to FlexibleColor.
            </summary>
            <param name="value">Color</param>
        </member>
        <member name="M:Arbor.FlexibleColor.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexibleComponent">
            <summary>
            Class to handle a flexible Component type reference method there is more than one.
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.ClassTypeConstraintAttribute" /></description></item>
            <item><description><see cref="T:Arbor.SlotTypeAttribute" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Arbor.FlexibleComponent.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleComponent.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleComponent.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleComponent.#ctor">
            <summary>
            FlexibleComponent default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleComponent.#ctor(UnityEngine.Component)">
            <summary>
            FlexibleComponent constructor
            </summary>
            <param name="component">Component</param>
        </member>
        <member name="M:Arbor.FlexibleComponent.#ctor(Arbor.ComponentParameterReference)">
            <summary>
            FlexibleComponent constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleComponent.#ctor(Arbor.InputSlotComponent)">
            <summary>
            FlexibleComponent constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleComponent.op_Explicit(Arbor.FlexibleComponent)~UnityEngine.Component">
            <summary>
            Cast FlexibleColor to Component.
            </summary>
            <param name="flexible">FlexibleComponent</param>
        </member>
        <member name="M:Arbor.FlexibleComponent.op_Explicit(UnityEngine.Component)~Arbor.FlexibleComponent">
            <summary>
            Cast Component to FlexibleComponent.
            </summary>
            <param name="value">Component</param>
        </member>
        <member name="M:Arbor.FlexibleComponent.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexibleEnumAny">
            <summary>
            Class to handle a flexible enum type reference method there is more than one.
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.ClassTypeConstraintAttribute" /></description></item>
            <item><description><see cref="T:Arbor.SlotTypeAttribute" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Arbor.FlexibleEnumAny.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleEnumAny.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleEnumAny.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleEnumAny.#ctor">
            <summary>
            FlexibleEnumAny default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleEnumAny.#ctor(System.Int32)">
            <summary>
            FlexibleEnumAny constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleEnumAny.#ctor(Arbor.AnyParameterReference)">
            <summary>
            FlexibleEnumAny constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleEnumAny.#ctor(Arbor.InputSlotAny)">
            <summary>
            FlexibleEnumAny constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleEnumAny.op_Explicit(Arbor.FlexibleEnumAny)~System.Int32">
            <summary>
            Cast FlexibleEnumAny to int.
            </summary>
            <param name="flexible">FlexibleEnumAny</param>
        </member>
        <member name="M:Arbor.FlexibleEnumAny.op_Explicit(System.Int32)~Arbor.FlexibleEnumAny">
            <summary>
            Cast int to FlexibleEnumAny.
            </summary>
            <param name="value">int</param>
        </member>
        <member name="M:Arbor.FlexibleEnumAny.GetEnumValue``1">
            <summary>
            Returns the enum type value.
            </summary>
            <typeparam name="T">Type of enum</typeparam>
            <returns>Value of enum type</returns>
        </member>
        <member name="M:Arbor.FlexibleEnumAny.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexibleFieldBase">
            <summary>
            A base class for dealing with flexible types with multiple reference methods.
            See <see cref="T:Arbor.FlexibleField`1"/> for use.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleFieldBase.fieldType">
            <summary>
            It returns a field type.
            </summary>
        </member>
        <member name="M:Arbor.FlexibleFieldBase.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexibleField`1">
            <summary>
            A base class for dealing with flexible types with multiple reference methods.
            To use it, inherit T by specifying a user-defined class.
            </summary>
            <typeparam name="T">Serializable type</typeparam>
        </member>
        <member name="P:Arbor.FlexibleField`1.fieldType">
            <summary>
            It returns a field type.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleField`1.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleField`1.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleField`1.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleField`1.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="M:Arbor.FlexibleField`1.#ctor">
            <summary>
            FlexibleField default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleField`1.#ctor(`0)">
            <summary>
            FlexibleField constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleField`1.#ctor(Arbor.AnyParameterReference)">
            <summary>
            FlexibleField constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleField`1.#ctor(Arbor.InputSlotAny)">
            <summary>
            FlexibleField constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleField`1.op_Explicit(Arbor.FlexibleField{`0})~`0">
            <summary>
            Cast FlexibleField to T.
            </summary>
            <param name="flexible">FlexibleField</param>
        </member>
        <member name="M:Arbor.FlexibleField`1.op_Explicit(`0)~Arbor.FlexibleField{`0}">
            <summary>
            Cast T to FlexibleField.
            </summary>
            <param name="value">T</param>
        </member>
        <member name="T:Arbor.FlexibleFloat">
            <summary>
            Class to handle a flexible float type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleFloat.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleFloat.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleFloat.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="M:Arbor.FlexibleFloat.#ctor">
            <summary>
            FlexibleFloat default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleFloat.#ctor(System.Single)">
            <summary>
            FlexibleFloat constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleFloat.#ctor(Arbor.FloatParameterReference)">
            <summary>
            FlexibleFloat constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleFloat.#ctor(System.Single,System.Single)">
            <summary>
            FlexibleFloat constructor
            </summary>
            <param name="minRange">Minimum range.</param>
            <param name="maxRange">Maximum range.</param>
        </member>
        <member name="M:Arbor.FlexibleFloat.#ctor(Arbor.InputSlotFloat)">
            <summary>
            FlexibleFloat constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleFloat.op_Explicit(Arbor.FlexibleFloat)~System.Single">
            <summary>
            Cast FlexibleFloat to float.
            </summary>
            <param name="flexible">FlexibleFloat</param>
        </member>
        <member name="M:Arbor.FlexibleFloat.op_Explicit(System.Single)~Arbor.FlexibleFloat">
            <summary>
            Cast float to FlexibleFloat.
            </summary>
            <param name="value">float</param>
        </member>
        <member name="T:Arbor.FlexibleGameObject">
            <summary>
            Class to handle a flexible GameObject type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleGameObject.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleGameObject.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleGameObject.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleGameObject.#ctor">
            <summary>
            FlexibleGameObject default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleGameObject.#ctor(UnityEngine.GameObject)">
            <summary>
            FlexibleGameObject constructor.
            </summary>
            <param name="gameObject">GameObject</param>
        </member>
        <member name="M:Arbor.FlexibleGameObject.#ctor(Arbor.GameObjectParameterReference)">
            <summary>
            FlexibleGameObject constructor.
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleGameObject.#ctor(Arbor.InputSlotGameObject)">
            <summary>
            FlexibleGameObject constructor.
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleGameObject.op_Explicit(Arbor.FlexibleGameObject)~UnityEngine.GameObject">
            <summary>
            Cast FlexibleGameObject to GameObject.
            </summary>
            <param name="flexible">FlexibleGameObject</param>
        </member>
        <member name="M:Arbor.FlexibleGameObject.op_Explicit(UnityEngine.GameObject)~Arbor.FlexibleGameObject">
            <summary>
            Cast GameObject to FlexibleGameObject.
            </summary>
            <param name="value">GameObject</param>
        </member>
        <member name="M:Arbor.FlexibleGameObject.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexibleInt">
            <summary>
            Class to handle a flexible int type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleInt.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleInt.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="P:Arbor.FlexibleInt.slot">
            <summary>
            It returns a slot
            </summary>
        </member>
        <member name="M:Arbor.FlexibleInt.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="M:Arbor.FlexibleInt.#ctor">
            <summary>
            FlexibleInt default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleInt.#ctor(System.Int32)">
            <summary>
            FlexibleInt constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleInt.#ctor(Arbor.IntParameterReference)">
            <summary>
            FlexibleInt constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleInt.#ctor(System.Int32,System.Int32)">
            <summary>
            FlexibleInt constructor
            </summary>
            <param name="minRange">Minimum range.</param>
            <param name="maxRange">Maximum range.</param>
        </member>
        <member name="M:Arbor.FlexibleInt.#ctor(Arbor.InputSlotInt)">
            <summary>
            FlexibleInt constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleInt.op_Explicit(Arbor.FlexibleInt)~System.Int32">
            <summary>
            Cast FlexibleInt to int.
            </summary>
            <param name="flexible">FlexibleInt</param>
        </member>
        <member name="M:Arbor.FlexibleInt.op_Explicit(System.Int32)~Arbor.FlexibleInt">
            <summary>
            Cast int to FlexibleInt.
            </summary>
            <param name="value">int</param>
        </member>
        <member name="T:Arbor.FlexibleLong">
            <summary>
            Class to handle a flexible long type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleLong.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleLong.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="P:Arbor.FlexibleLong.slot">
            <summary>
            It returns a slot
            </summary>
        </member>
        <member name="M:Arbor.FlexibleLong.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="M:Arbor.FlexibleLong.#ctor">
            <summary>
            FlexibleLong default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleLong.#ctor(System.Int64)">
            <summary>
            FlexibleLong constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleLong.#ctor(Arbor.LongParameterReference)">
            <summary>
            FlexibleLong constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleLong.#ctor(System.Int64,System.Int64)">
            <summary>
            FlexibleLong constructor
            </summary>
            <param name="minRange">Minimum range.</param>
            <param name="maxRange">Maximum range.</param>
        </member>
        <member name="M:Arbor.FlexibleLong.#ctor(Arbor.InputSlotLong)">
            <summary>
            FlexibleLong constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleLong.op_Explicit(Arbor.FlexibleLong)~System.Int64">
            <summary>
            Cast FlexibleLong to long.
            </summary>
            <param name="flexible">FlexiblFlexibleLongeInt</param>
        </member>
        <member name="M:Arbor.FlexibleLong.op_Explicit(System.Int64)~Arbor.FlexibleLong">
            <summary>
            Cast long to FlexibleLong.
            </summary>
            <param name="value">long</param>
        </member>
        <member name="T:Arbor.FlexiblePrimitiveBase">
            <summary>
            Class to handle a flexible primitive type reference method there is more than one. Inherit and use it.
            </summary>
        </member>
        <member name="F:Arbor.FlexiblePrimitiveBase._Type">
            <summary>
            Reference type of primitive type
            </summary>
        </member>
        <member name="P:Arbor.FlexiblePrimitiveBase.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="M:Arbor.FlexiblePrimitiveBase.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexiblePrimitiveType">
            <summary>
            Reference types used in the Flexible class for primitive data
            </summary>
        </member>
        <member name="F:Arbor.FlexiblePrimitiveType.Constant">
            <summary>
            Constant
            </summary>
        </member>
        <member name="F:Arbor.FlexiblePrimitiveType.Parameter">
            <summary>
            Parameter
            </summary>
        </member>
        <member name="F:Arbor.FlexiblePrimitiveType.Random">
            <summary>
            Random
            </summary>
        </member>
        <member name="F:Arbor.FlexiblePrimitiveType.Calculator">
            <summary>
            Data slot
            </summary>
        </member>
        <member name="F:Arbor.FlexiblePrimitiveType.DataSlot">
            <summary>
            Data slot
            </summary>
        </member>
        <member name="T:Arbor.FlexibleQuaternion">
            <summary>
            Class to handle a flexible Quaternion type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleQuaternion.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleQuaternion.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleQuaternion.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleQuaternion.#ctor">
            <summary>
            FlexibleQuaternion default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleQuaternion.#ctor(UnityEngine.Quaternion)">
            <summary>
            FlexibleQuaternion constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleQuaternion.#ctor(Arbor.QuaternionParameterReference)">
            <summary>
            FlexibleQuaternion constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleQuaternion.#ctor(Arbor.InputSlotQuaternion)">
            <summary>
            FlexibleQuaternion constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleQuaternion.op_Explicit(Arbor.FlexibleQuaternion)~UnityEngine.Quaternion">
            <summary>
            Cast FlexibleQuaternion to Quaternion.
            </summary>
            <param name="flexible">FlexibleQuaternion</param>
        </member>
        <member name="M:Arbor.FlexibleQuaternion.op_Explicit(UnityEngine.Quaternion)~Arbor.FlexibleQuaternion">
            <summary>
            Cast Quaternion to FlexibleQuaternion.
            </summary>
            <param name="value">Quaternion</param>
        </member>
        <member name="M:Arbor.FlexibleQuaternion.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexibleRect">
            <summary>
            Class to handle a flexible Rect type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleRect.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleRect.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleRect.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleRect.#ctor">
            <summary>
            FlexibleRect default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleRect.#ctor(UnityEngine.Rect)">
            <summary>
            FlexibleRect constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleRect.#ctor(Arbor.RectParameterReference)">
            <summary>
            FlexibleRect constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleRect.#ctor(Arbor.InputSlotRect)">
            <summary>
            FlexibleRect constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleRect.op_Explicit(Arbor.FlexibleRect)~UnityEngine.Rect">
            <summary>
            Cast FlexibleRect to Rect.
            </summary>
            <param name="flexible">FlexibleRect</param>
        </member>
        <member name="M:Arbor.FlexibleRect.op_Explicit(UnityEngine.Rect)~Arbor.FlexibleRect">
            <summary>
            Cast Rect to FlexibleRect.
            </summary>
            <param name="value">Rect</param>
        </member>
        <member name="M:Arbor.FlexibleRect.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexibleRectTransform">
            <summary>
            Class to handle a flexible RectTransform type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleRectTransform.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleRectTransform.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleRectTransform.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleRectTransform.#ctor">
            <summary>
            FlexibleRectTransform default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleRectTransform.#ctor(UnityEngine.RectTransform)">
            <summary>
            FlexibleRectTransform constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleRectTransform.#ctor(Arbor.RectTransformParameterReference)">
            <summary>
            FlexibleRectTransform constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleRectTransform.#ctor(Arbor.InputSlotRectTransform)">
            <summary>
            FlexibleRectTransform constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleRectTransform.op_Explicit(Arbor.FlexibleRectTransform)~UnityEngine.RectTransform">
            <summary>
            Cast FlexibleRectTransform to RectTransform.
            </summary>
            <param name="flexible">FlexibleRectTransform</param>
        </member>
        <member name="M:Arbor.FlexibleRectTransform.op_Explicit(UnityEngine.RectTransform)~Arbor.FlexibleRectTransform">
            <summary>
            Cast RectTransform to FlexibleRectTransform.
            </summary>
            <param name="value">RectTransform</param>
        </member>
        <member name="M:Arbor.FlexibleRectTransform.ToFlexibleComponent">
            <summary>
            Convert to FlexibleComponent and return it.
            </summary>
            <returns>FlexibleComponent</returns>
        </member>
        <member name="M:Arbor.FlexibleRectTransform.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexibleRigidbody">
            <summary>
            Class to handle a flexible Rigidbody type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleRigidbody.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleRigidbody.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleRigidbody.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleRigidbody.#ctor">
            <summary>
            FlexibleRigidbody default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleRigidbody.#ctor(UnityEngine.Rigidbody)">
            <summary>
            FlexibleRigidbody constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleRigidbody.#ctor(Arbor.RigidbodyParameterReference)">
            <summary>
            FlexibleRigidbody constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleRigidbody.#ctor(Arbor.InputSlotRigidbody)">
            <summary>
            FlexibleRigidbody constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleRigidbody.op_Explicit(Arbor.FlexibleRigidbody)~UnityEngine.Rigidbody">
            <summary>
            Cast FlexibleRigidbody to Rigidbody.
            </summary>
            <param name="flexible">FlexibleRigidbody</param>
        </member>
        <member name="M:Arbor.FlexibleRigidbody.op_Explicit(UnityEngine.Rigidbody)~Arbor.FlexibleRigidbody">
            <summary>
            Cast Rigidbody to FlexibleRigidbody.
            </summary>
            <param name="value">Rigidbody</param>
        </member>
        <member name="M:Arbor.FlexibleRigidbody.ToFlexibleComponent">
            <summary>
            Convert to FlexibleComponent and return it.
            </summary>
            <returns>FlexibleComponent</returns>
        </member>
        <member name="M:Arbor.FlexibleRigidbody.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexibleRigidbody2D">
            <summary>
            Class to handle a flexible Rigidbody2D type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleRigidbody2D.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleRigidbody2D.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleRigidbody2D.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleRigidbody2D.#ctor">
            <summary>
            FlexibleRigidbody2D default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleRigidbody2D.#ctor(UnityEngine.Rigidbody2D)">
            <summary>
            FlexibleRigidbody2D constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleRigidbody2D.#ctor(Arbor.Rigidbody2DParameterReference)">
            <summary>
            FlexibleRigidbody2D constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleRigidbody2D.#ctor(Arbor.InputSlotRigidbody2D)">
            <summary>
            FlexibleRigidbody2D constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleRigidbody2D.op_Explicit(Arbor.FlexibleRigidbody2D)~UnityEngine.Rigidbody2D">
            <summary>
            Cast FlexibleRigidbody2D to Rigidbody2D.
            </summary>
            <param name="flexible">FlexibleRigidbody2D</param>
        </member>
        <member name="M:Arbor.FlexibleRigidbody2D.op_Explicit(UnityEngine.Rigidbody2D)~Arbor.FlexibleRigidbody2D">
            <summary>
            Cast Rigidbody2D to FlexibleRigidbody2D.
            </summary>
            <param name="value">Rigidbody2D</param>
        </member>
        <member name="M:Arbor.FlexibleRigidbody2D.ToFlexibleComponent">
            <summary>
            Convert to FlexibleComponent and return it.
            </summary>
            <returns>FlexibleComponent</returns>
        </member>
        <member name="M:Arbor.FlexibleRigidbody2D.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexibleString">
            <summary>
            Class to handle a flexible string type reference method there is more than one.
            </summary>
            <remarks>
            When FlexibleType.Constant, you can display multiple fields of editor fields by attaching the <see cref="T:Arbor.ConstantMultilineAttribute"/> attribute.
            </remarks>
        </member>
        <member name="P:Arbor.FlexibleString.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleString.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleString.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleString.#ctor">
            <summary>
            FlexibleString default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleString.#ctor(System.String)">
            <summary>
            FlexibleString constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleString.#ctor(Arbor.StringParameterReference)">
            <summary>
            FlexibleString constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleString.#ctor(Arbor.InputSlotString)">
            <summary>
            FlexibleString constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleString.op_Explicit(Arbor.FlexibleString)~System.String">
            <summary>
            Cast FlexibleString to string.
            </summary>
            <param name="flexible">FlexibleString</param>
        </member>
        <member name="M:Arbor.FlexibleString.op_Explicit(System.String)~Arbor.FlexibleString">
            <summary>
            Cast string to FlexibleString.
            </summary>
            <param name="value">string</param>
        </member>
        <member name="M:Arbor.FlexibleString.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexibleTransform">
            <summary>
            Class to handle a flexible Transform type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleTransform.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleTransform.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleTransform.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleTransform.#ctor">
            <summary>
            FlexibleTransform default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleTransform.#ctor(UnityEngine.Transform)">
            <summary>
            FlexibleTransform constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleTransform.#ctor(Arbor.TransformParameterReference)">
            <summary>
            FlexibleTransform constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleTransform.#ctor(Arbor.InputSlotTransform)">
            <summary>
            FlexibleTransform constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleTransform.op_Explicit(Arbor.FlexibleTransform)~UnityEngine.Transform">
            <summary>
            Cast FlexibleTransform to Transform.
            </summary>
            <param name="flexible">FlexibleTransform</param>
        </member>
        <member name="M:Arbor.FlexibleTransform.op_Explicit(UnityEngine.Transform)~Arbor.FlexibleTransform">
            <summary>
            Cast Transform to FlexibleTransform.
            </summary>
            <param name="value">Transform</param>
        </member>
        <member name="M:Arbor.FlexibleTransform.ToFlexibleComponent">
            <summary>
            Convert to FlexibleComponent and return it.
            </summary>
            <returns>FlexibleComponent</returns>
        </member>
        <member name="M:Arbor.FlexibleTransform.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexibleType">
            <summary>
            Reference type used in Flexible class
            </summary>
        </member>
        <member name="F:Arbor.FlexibleType.Constant">
            <summary>
            Constant
            </summary>
        </member>
        <member name="F:Arbor.FlexibleType.Parameter">
            <summary>
            Parameter
            </summary>
        </member>
        <member name="F:Arbor.FlexibleType.Calculator">
            <summary>
            Data slot
            </summary>
        </member>
        <member name="F:Arbor.FlexibleType.DataSlot">
            <summary>
            Data slot
            </summary>
        </member>
        <member name="T:Arbor.FlexibleVector2">
            <summary>
            Class to handle a flexible Vector2 type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleVector2.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleVector2.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleVector2.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleVector2.#ctor">
            <summary>
            FlexibleVector2 default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleVector2.#ctor(UnityEngine.Vector2)">
            <summary>
            FlexibleVector2 constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleVector2.#ctor(Arbor.Vector2ParameterReference)">
            <summary>
            FlexibleVector2 constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleVector2.#ctor(Arbor.InputSlotVector2)">
            <summary>
            FlexibleVector2 constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleVector2.op_Explicit(Arbor.FlexibleVector2)~UnityEngine.Vector2">
            <summary>
            Cast FlexibleVector2 to Vector2.
            </summary>
            <param name="flexible">FlexibleVector2</param>
        </member>
        <member name="M:Arbor.FlexibleVector2.op_Explicit(UnityEngine.Vector2)~Arbor.FlexibleVector2">
            <summary>
            Cast Vector2 to FlexibleVector2.
            </summary>
            <param name="value">Vector2</param>
        </member>
        <member name="M:Arbor.FlexibleVector2.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.FlexibleVector3">
            <summary>
            Class to handle a flexible Vector3 type reference method there is more than one.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleVector3.type">
            <summary>
            It returns a type
            </summary>
        </member>
        <member name="P:Arbor.FlexibleVector3.parameter">
            <summary>
            It return a Paramter. It is null if Type is other than Parameter.
            </summary>
        </member>
        <member name="P:Arbor.FlexibleVector3.value">
            <summary>
            It returns a value
            </summary>
        </member>
        <member name="M:Arbor.FlexibleVector3.#ctor">
            <summary>
            FlexibleVector3 default constructor
            </summary>
        </member>
        <member name="M:Arbor.FlexibleVector3.#ctor(UnityEngine.Vector3)">
            <summary>
            FlexibleVector3 constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleVector3.#ctor(Arbor.Vector3ParameterReference)">
            <summary>
            FlexibleVector3 constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleVector3.#ctor(Arbor.InputSlotVector3)">
            <summary>
            FlexibleVector3 constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleVector3.op_Explicit(Arbor.FlexibleVector3)~UnityEngine.Vector3">
            <summary>
            Cast FlexibleVector3 to Vector3.
            </summary>
            <param name="flexible">FlexibleVector3</param>
        </member>
        <member name="M:Arbor.FlexibleVector3.op_Explicit(UnityEngine.Vector3)~Arbor.FlexibleVector3">
            <summary>
            Cast Vector3 to FlexibleVector3.
            </summary>
            <param name="value">Vector3</param>
        </member>
        <member name="M:Arbor.FlexibleVector3.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.IFlexibleField">
            <summary>
            FlexibleField interface
            </summary>
        </member>
        <member name="M:Arbor.IFlexibleField.GetValueObject">
            <summary>
            Return the value as object.
            </summary>
            <returns>The value object</returns>
        </member>
        <member name="T:Arbor.GlobalParameterContainerInternal">
            <summary>
            Class dealing with the accessible ParameterContainer even across the scene.
            </summary>
        </member>
        <member name="F:Arbor.GlobalParameterContainerInternal._Prefab">
            <summary>
            ParameterContainer
            </summary>
        </member>
        <member name="P:Arbor.GlobalParameterContainerInternal.prefab">
             <summary>
            It returns the original ParameterContainer.
             </summary>
        </member>
        <member name="P:Arbor.GlobalParameterContainerInternal.instance">
            <summary>
            It returns the ParameterContainer entity.
            </summary>
        </member>
        <member name="T:Arbor.GroupNode">
            <summary>
            Class that represents the group node
            </summary>
        </member>
        <member name="T:Arbor.GroupNode.AutoAlignment">
            <summary>
            Auto Alignment
            </summary>
        </member>
        <member name="F:Arbor.GroupNode.AutoAlignment.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Arbor.GroupNode.AutoAlignment.Vertical">
            <summary>
            Vertical
            </summary>
        </member>
        <member name="F:Arbor.GroupNode.AutoAlignment.Horizonal">
            <summary>
            Horizontal
            </summary>
        </member>
        <member name="F:Arbor.GroupNode.name">
            <summary>
            The name of the group node.
            </summary>
        </member>
        <member name="F:Arbor.GroupNode.color">
            <summary>
            Node color
            </summary>
        </member>
        <member name="F:Arbor.GroupNode.autoAlignment">
            <summary>
            Auto Layout
            </summary>
        </member>
        <member name="M:Arbor.GroupNode.#ctor(Arbor.NodeGraph,System.Int32)">
            <summary>
            GroupNode constructor
            </summary>
            <param name="nodeGraph">NodeGraph with this node</param>
            <param name="nodeID">Node ID</param>
            <remarks>
            Please use the <see cref = "M:Arbor.NodeGraph.CreateGroup" /> group node creating.
            </remarks>
        </member>
        <member name="M:Arbor.GroupNode.GetName">
            <summary>
            Get node name.
            </summary>
            <returns>Node name</returns>
        </member>
        <member name="T:Arbor.HideBehaviour">
            <summary>
            The attributes you do not want to display to AddBehaviour menu.
            </summary>
        </member>
        <member name="M:Arbor.HideBehaviour.#ctor">
            <summary>
            HideBehaviour constructor
            </summary>
        </member>
        <member name="T:Arbor.HideSlotFields">
            <summary>
            Attribute to hide additional fields of DataSlot
            </summary>
            <remarks>
            Available classes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.OutputSlotComponent"/></description></item>
            <item><description><see cref="T:Arbor.OutputSlotUnityObject"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Arbor.IComponentProcessor">
            <summary>
            Interface for Editor processing such as Undo. Used with ComponentUtility.
            </summary>
        </member>
        <member name="M:Arbor.IComponentProcessor.AddComponent(UnityEngine.GameObject,System.Type)">
            <summary>
            Add component.
            </summary>
            <param name="gameObject">GameObject</param>
            <param name="type">Component type</param>
            <returns>Component</returns>
        </member>
        <member name="M:Arbor.IComponentProcessor.Destroy(UnityEngine.Object)">
            <summary>
            Destroy object.
            </summary>
            <param name="objectToUndo">Object</param>
        </member>
        <member name="M:Arbor.IComponentProcessor.RecordObject(UnityEngine.Object,System.String)">
            <summary>
            Record object.
            </summary>
            <param name="objectToUndo">Object</param>
            <param name="name">Name</param>
        </member>
        <member name="M:Arbor.IComponentProcessor.RecordObjects(UnityEngine.Object[],System.String)">
            <summary>
            Records object.
            </summary>
            <param name="objs">Objects</param>
            <param name="name">Name</param>
        </member>
        <member name="M:Arbor.IComponentProcessor.RegisterCompleteObjectUndo(UnityEngine.Object,System.String)">
            <summary>
            Register Object in Undo.
            </summary>
            <param name="objectToUndo">Object</param>
            <param name="name">Name</param>
        </member>
        <member name="M:Arbor.IComponentProcessor.SetDirty(UnityEngine.Object)">
            <summary>
            Marks an Object as dirty.
            </summary>
            <param name="obj">Object</param>
        </member>
        <member name="M:Arbor.IComponentProcessor.MoveBehaviour(Arbor.Node,Arbor.NodeBehaviour)">
            <summary>
            Move behavior to node.
            </summary>
            <param name="node">Moving destination node</param>
            <param name="behaviour">Moving NodeBehaviour</param>
        </member>
        <member name="M:Arbor.IComponentProcessor.MoveVariable(Arbor.Parameter,Arbor.VariableBase)">
            <summary>
            Move variable to parameter. Valid only in Editor.
            </summary>
            <param name="parameter">Moving destination Parameter</param>
            <param name="variable">Moving VariableBase</param>
        </member>
        <member name="M:Arbor.IComponentProcessor.DelayDestroy(UnityEngine.Object)">
            <summary>
            Delay Destroy.
            </summary>
            <param name="obj">Object</param>
        </member>
        <member name="M:Arbor.IComponentProcessor.DelayCall(Arbor.ComponentUtility.DelayCallBack)">
            <summary>
            Delay call.
            </summary>
            <param name="delayCall">Method to call</param>
        </member>
        <member name="T:Arbor.INodeBehaviourContainer">
            <summary>
            Interface to use if Node is a NodeBehaviour container
            </summary>
        </member>
        <member name="M:Arbor.INodeBehaviourContainer.GetNodeBehaviourCount">
            <summary>
            Get count of NodeBehaviour.
            </summary>
            <returns>Count of NodeBehaviour</returns>
        </member>
        <member name="M:Arbor.INodeBehaviourContainer.GetNodeBehaviour``1(System.Int32)">
            <summary>
            Get NodeBehaviour
            </summary>
            <typeparam name="T">NodeBehaviour type</typeparam>
            <param name="index">Index</param>
            <returns>NodeBehaviour</returns>
        </member>
        <member name="M:Arbor.INodeBehaviourContainer.SetNodeBehaviour(System.Int32,Arbor.NodeBehaviour)">
            <summary>
            Set NodeBehaviour
            </summary>
            <param name="index">Index</param>
            <param name="behaviour">NodeBehaviour</param>
            <remarks>Since destruction of the NodeBehavior which was originally in the specified index is not guaranteed, refer to each node for addition and deletion.</remarks>
        </member>
        <member name="T:Arbor.INodeBehaviourSerializationCallbackReceiver">
            <summary>
            Interface to receive callbacks upon serialization and deserialization.
            </summary>
            <remarks>Used for classes that inherit from NodeBehaviour.</remarks>
        </member>
        <member name="M:Arbor.INodeBehaviourSerializationCallbackReceiver.OnBeforeSerialize">
            <summary>
            Serialization Callback.
            </summary>
            <remarks>It is called from ISerializationCallbackReceiver.OnBeforeSerialize() of NodeBehaviour.</remarks>
        </member>
        <member name="M:Arbor.INodeBehaviourSerializationCallbackReceiver.OnAfterDeserialize">
            <summary>
            Serialization Callback.
            </summary>
            <remarks>It is called from ISerializationCallbackReceiver.OnAfterDeserialize() of NodeBehaviour.</remarks>
        </member>
        <member name="T:Arbor.INodeGraphContainer">
            <summary>
            Interface to use if NodeBehaviour is a NodeGraph container
            </summary>
        </member>
        <member name="M:Arbor.INodeGraphContainer.GetNodeGraphCount">
            <summary>
            Get count of NodeGraph.
            </summary>
            <returns>Count of NodeGraph</returns>
        </member>
        <member name="M:Arbor.INodeGraphContainer.GetNodeGraph``1(System.Int32)">
            <summary>
            Get NodeGraph.
            </summary>
            <typeparam name="T">NodeGraph type.</typeparam>
            <param name="index">Index</param>
            <returns>NodeGraph</returns>
        </member>
        <member name="M:Arbor.INodeGraphContainer.SetNodeGraph(System.Int32,Arbor.NodeGraph)">
            <summary>
            Set NodeGraph.
            </summary>
            <param name="index">Index</param>
            <param name="graph">NodeGraph</param>
            <remarks>Since the destruction of the NodeGraph originally from the specified index is not guaranteed, refer to each NodeBehaviour for addition and deletion.</remarks>
        </member>
        <member name="M:Arbor.INodeGraphContainer.OnFinishNodeGraph(Arbor.NodeGraph,System.Boolean)">
            <summary>
            This function is called when NodeGraph finishes.
            </summary>
            <param name="graph">NodeGraph</param>
            <param name="success">Whether it is successful or not</param>
        </member>
        <member name="T:Arbor.Internal.AnimatorParameterTypeAttribute">
            <summary>
            An attribute that specifies AnimatorControllerParameterType as a derived class of AnimatorParameterReference
            </summary>
        </member>
        <member name="P:Arbor.Internal.AnimatorParameterTypeAttribute.parameterType">
            <summary>
            The specified AnimatorControllerParameterType
            </summary>
        </member>
        <member name="M:Arbor.Internal.AnimatorParameterTypeAttribute.#ctor(UnityEngine.AnimatorControllerParameterType)">
            <summary>
            Specifying AnimatorControllerParameterType
            </summary>
            <param name="parameterType">AnimatorControllerParameterType</param>
        </member>
        <member name="T:Arbor.Internal.ConstraintableAttribute">
            <summary>
            Attribute that specifies that it can be constrained to a derived class of ParameterReference
            </summary>
        </member>
        <member name="P:Arbor.Internal.ConstraintableAttribute.baseType">
            <summary>
            Base type of constraint
            </summary>
        </member>
        <member name="M:Arbor.Internal.ConstraintableAttribute.#ctor">
            <summary>
            Specify that it can be constrained
            </summary>
        </member>
        <member name="M:Arbor.Internal.ConstraintableAttribute.#ctor(System.Type)">
            <summary>
            Specify that it can be constrained
            </summary>
            <param name="baseType">Base type of constraint</param>
        </member>
        <member name="T:Arbor.Internal.DocumentableAttribute">
            <summary>
            Inner class to use when documenting.
            </summary>
        </member>
        <member name="T:Arbor.Internal.HideInDocument">
            <summary>
            Attributes to hide in documents
            </summary>
        </member>
        <member name="T:Arbor.Internal.ParameterTypeAttribute">
            <summary>
            An attribute that specifies Parameter.Type as a derived class of ParameterReference
            </summary>
        </member>
        <member name="P:Arbor.Internal.ParameterTypeAttribute.parameterType">
            <summary>
            The specified Parameter.Type
            </summary>
        </member>
        <member name="M:Arbor.Internal.ParameterTypeAttribute.#ctor(Arbor.Parameter.Type)">
            <summary>
            Specifying Parameter.Type
            </summary>
            <param name="parameterType">Parameter.Type</param>
        </member>
        <member name="T:Arbor.Node">
            <summary>
            Base class of a node in Arbor Editor
            </summary>
        </member>
        <member name="F:Arbor.Node.position">
            <summary>
            Position on the Arbor Editor.
            </summary>
        </member>
        <member name="F:Arbor.Node.showComment">
            <summary>
            Whether to display comments
            </summary>
        </member>
        <member name="F:Arbor.Node.nodeComment">
            <summary>
            Comment
            </summary>
        </member>
        <member name="P:Arbor.Node.nodeGraph">
            <summary>
            Gets the NodeGraph.
            </summary>
        </member>
        <member name="P:Arbor.Node.nodeID">
            <summary>
            Gets the node identifier.
            </summary>
        </member>
        <member name="M:Arbor.Node.#ctor(Arbor.NodeGraph,System.Int32)">
            <summary>
            Node constructor
            </summary>
            <param name="nodeGraph">NodeGraph with this node</param>
            <param name="nodeID">Node ID</param>
        </member>
        <member name="M:Arbor.Node.OnGraphChanged">
            <summary>
            Called when the NodeGraph to which the Node belongs has changed.
            </summary>
        </member>
        <member name="M:Arbor.Node.IsContainsBehaviour(Arbor.NodeBehaviour)">
            <summary>
            Check if it contains NodeBehaviour.
            </summary>
            <param name="behaviour">Check NodeBehaviour</param>
            <returns>Returns true if it contains NodeBehaviour.</returns>
        </member>
        <member name="M:Arbor.Node.IsDeletable">
            <summary>
            Returns whether or not it can be deleted.
            </summary>
            <returns>Returns true if it can be deleted.</returns>
        </member>
        <member name="M:Arbor.Node.ChangeGraph(Arbor.NodeGraph)">
            <summary>
            For Editor.
            </summary>
        </member>
        <member name="M:Arbor.Node.GetName">
            <summary>
            Get node name.
            </summary>
            <returns>Node name</returns>
        </member>
        <member name="M:Arbor.Node.ToString">
            <summary>
            Convert node to string (for debugging).
            </summary>
            <returns>Converted string</returns>
        </member>
        <member name="T:Arbor.NodeBehaviour">
            <summary>
            Base class for scripts to be assigned to various nodes of ArborFSM.
            </summary>
        </member>
        <member name="P:Arbor.NodeBehaviour.nodeGraph">
            <summary>
            Gets the NodeGraph.
            </summary>
        </member>
        <member name="P:Arbor.NodeBehaviour.nodeID">
            <summary>
            Gets the node identifier.
            </summary>
        </member>
        <member name="P:Arbor.NodeBehaviour.node">
            <summary>
            Get the Node.
            </summary>
        </member>
        <member name="M:Arbor.NodeBehaviour.OnValidate">
            <summary>
            See MonoBehaviour.OnValidate.
            </summary>
        </member>
        <member name="M:Arbor.NodeBehaviour.RebuildFields">
            <summary>
            For Editor.
            </summary>
        </member>
        <member name="M:Arbor.NodeBehaviour.CreateNodeBehaviour(Arbor.Node,System.Type,System.Boolean)">
            <summary>
            For Editor.
            </summary>
        </member>
        <member name="M:Arbor.NodeBehaviour.CreateNodeBehaviour``1(Arbor.Node,System.Boolean)">
            <summary>
            For Editor.
            </summary>
        </member>
        <member name="M:Arbor.NodeBehaviour.Destroy(Arbor.NodeBehaviour)">
            <summary>
            Destroy NodeBehaviour.
            </summary>
            <param name="behaviour">NodeBehaviour</param>
        </member>
        <member name="P:Arbor.NodeBehaviour.dataSlotFieldCount">
            <summary>
            Number of DataSlotField
            </summary>
        </member>
        <member name="P:Arbor.NodeBehaviour.calculatorSlotFieldCount">
            <summary>
            Number of DataSlotField
            </summary>
        </member>
        <member name="M:Arbor.NodeBehaviour.GetDataSlotField(System.Int32)">
            <summary>
            Get DataSlotField.
            </summary>
            <param name="index">Index</param>
            <returns>DataSlotField</returns>
        </member>
        <member name="M:Arbor.NodeBehaviour.GetCalculatorSlotField(System.Int32)">
            <summary>
            Get DataSlotField.
            </summary>
            <param name="index">Index</param>
            <returns>DataSlotField</returns>
        </member>
        <member name="M:Arbor.NodeBehaviour.GetDataSlotField(Arbor.DataSlot)">
            <summary>
            Get DataSlotField.
            </summary>
            <param name="slot">DataSlot</param>
            <returns>DataSlotField</returns>
        </member>
        <member name="M:Arbor.NodeBehaviour.GetCalculatorSlotField(Arbor.DataSlot)">
            <summary>
            Get DataSlotField.
            </summary>
            <param name="slot">DataSlot</param>
            <returns>DataSlotField</returns>
        </member>
        <member name="M:Arbor.NodeBehaviour.RebuildDataSlotFields">
            <summary>
            Rebuild the DataSlotField.
            </summary>
            <remarks>It is necessary to call it when changing the number of fields of DataSlot at runtime.</remarks>
        </member>
        <member name="M:Arbor.NodeBehaviour.RebuildCalculatorSlotFields">
            <summary>
            Rebuild the DataSlotField.
            </summary>
            <remarks>It is necessary to call it when changing the number of fields of DataSlot at runtime.</remarks>
        </member>
        <member name="M:Arbor.NodeBehaviour.Initialize(Arbor.NodeGraph,System.Int32)">
            <summary>
            For Editor.
            </summary>
            <param name="nodeGraph">NodeGraph</param>
            <param name="nodeID">Node ID</param>
        </member>
        <member name="M:Arbor.NodeBehaviour.OnCreated">
            <summary>
            Raises the created event.
            </summary>
        </member>
        <member name="M:Arbor.NodeBehaviour.OnInitializeEnabled">
            <summary>
            Called to perform enabled initialization.
            </summary>
        </member>
        <member name="M:Arbor.NodeBehaviour.OnPreDestroy">
            <summary>
            Raises the pre destroy event.
            </summary>
        </member>
        <member name="M:Arbor.NodeBehaviour.OnGraphPause">
            <summary>
            This function is called when the graph is paused.
            </summary>
        </member>
        <member name="M:Arbor.NodeBehaviour.OnGraphResume">
            <summary>
            This function is called when the graph resumes.
            </summary>
        </member>
        <member name="M:Arbor.NodeBehaviour.OnGraphStop">
            <summary>
            This function is called when the graph stops.
            </summary>
        </member>
        <member name="T:Arbor.NodeBehaviourList`1">
            <summary>
            NodeBehaviour list
            </summary>
            <typeparam name="T">NodeBehaviour type</typeparam>
        </member>
        <member name="P:Arbor.NodeBehaviourList`1.count">
            <summary>
            Count
            </summary>
        </member>
        <member name="P:Arbor.NodeBehaviourList`1.Item(System.Int32)">
            <summary>
            Access to specified index
            </summary>
            <param name="i">Index</param>
            <returns>NodeBehaviour stored in the index</returns>
        </member>
        <member name="M:Arbor.NodeBehaviourList`1.Add(`0)">
            <summary>
            Adds the Behaviour.
            </summary>
            <param name="behaviour">Add NodeBehaviour</param>
        </member>
        <member name="M:Arbor.NodeBehaviourList`1.Insert(System.Int32,`0)">
            <summary>
            Insert the Behaviour.
            </summary>
            <param name="index">Insertion destination index</param>
            <param name="behaviour">Insert NodeBehaviour</param>
        </member>
        <member name="M:Arbor.NodeBehaviourList`1.GetObject(System.Int32)">
            <summary>
            Get Object of NodeBehaviour from index.
            </summary>
            <param name="index">Index</param>
            <returns>Object</returns>
        </member>
        <member name="M:Arbor.NodeBehaviourList`1.SetObject(System.Int32,UnityEngine.Object)">
            <summary>
            Set Object of NodeBehaviour to index.
            </summary>
            <param name="index">Index</param>
            <param name="obj">Object</param>
        </member>
        <member name="M:Arbor.NodeBehaviourList`1.IndexOf(UnityEngine.Object)">
            <summary>
            Return index of NodeBehaviour.
            </summary>
            <param name="obj">The NodeBehaviour to locate in the State.</param>
            <returns>Returns an index if found, -1 otherwise.</returns>
        </member>
        <member name="M:Arbor.NodeBehaviourList`1.Swap(System.Int32,System.Int32)">
            <summary>
            Swap the order of NodeBehaviour.
            </summary>
            <param name="fromIndex">The swapping want index.</param>
            <param name="toIndex">Exchange destination index.</param>
        </member>
        <member name="M:Arbor.NodeBehaviourList`1.Move(System.Int32,System.Int32)">
            <summary>
            Move the order of NodeBehaviour.
            </summary>
            <param name="fromIndex">The moving want index.</param>
            <param name="toIndex">The destination index.</param>
        </member>
        <member name="M:Arbor.NodeBehaviourList`1.Destroy(Arbor.Node,UnityEngine.Object)">
            <summary>
            Destroy NodeBehaviour
            </summary>
            <param name="node">Node that has NodeBehaviour</param>
            <param name="behaviour">Object of NodeBehaviour</param>
        </member>
        <member name="M:Arbor.NodeBehaviourList`1.DestroyAll(Arbor.Node)">
            <summary>
            Destroy All NodeBehaviour.
            </summary>
            <param name="node">Node that has NodeBehaviour</param>
        </member>
        <member name="M:Arbor.NodeBehaviourList`1.MoveBehaviour(Arbor.Node)">
            <summary>
            Move NodeBehaviour to node. Valid only in Editor.
            </summary>
            <param name="node">Moving destination node</param>
        </member>
        <member name="M:Arbor.NodeBehaviourList`1.Contains(`0)">
            <summary>
            Returns whether it contains behaviour.
            </summary>
            <param name="behaviour">Check target</param>
            <returns>Returns true if it contains.</returns>
        </member>
        <member name="M:Arbor.NodeBehaviourList`1.ContainsObject(UnityEngine.Object)">
            <summary>
            Returns whether it contains obj.
            </summary>
            <param name="obj">Check target</param>
            <returns>Returns true if it contains.</returns>
        </member>
        <member name="T:Arbor.NodeGraph">
            <summary>
            Base class of node graph.
            </summary>
        </member>
        <member name="F:Arbor.NodeGraph.graphName">
            <summary>
            The Graph name.<br/>
            It is used for identification and retrieval when there is more than one Graph in one GameObject.
            </summary>
        </member>
        <member name="F:Arbor.NodeGraph.debugInfiniteLoopSettings">
            <summary>
            Debug setting of infinite loop
            </summary>
        </member>
        <member name="P:Arbor.NodeGraph.parentGraph">
            <summary>
            Parent graph
            </summary>
        </member>
        <member name="P:Arbor.NodeGraph.rootGraph">
            <summary>
            Root graph
            </summary>
        </member>
        <member name="P:Arbor.NodeGraph.ownerBehaviourObject">
            <summary>
            Object of NodeBehaviour own this graph
            </summary>
        </member>
        <member name="P:Arbor.NodeGraph.ownerBehaviour">
            <summary>
            NodeBehaviour is the owner of this graph
            </summary>
        </member>
        <member name="P:Arbor.NodeGraph.parameterContainer">
            <summary>
            The ParameterContainer assigned in this graph
            </summary>
        </member>
        <member name="P:Arbor.NodeGraph.displayGraphName">
            <summary>
            Display name of the node graph. If graphName is empty or null, it returns "(No Name)".
            </summary>
        </member>
        <member name="P:Arbor.NodeGraph.currentDebugInfiniteLoopSettings">
            <summary>
            Current infinite loop debug setting.
            </summary>
            <remarks>If it is a child graph, return the infinite loop debug setting of the route graph.</remarks>
        </member>
        <member name="P:Arbor.NodeGraph.external">
            <summary>
            Flag instantiated from external graph
            </summary>
        </member>
        <member name="P:Arbor.NodeGraph.nodeCount">
            <summary>
             Get a count of Node.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.GetNodeFromIndex(System.Int32)">
            <summary>
            Get Node from index.
            </summary>
            <param name="index">Index</param>
            <returns>Node</returns>
        </member>
        <member name="M:Arbor.NodeGraph.GetNodeFromID(System.Int32)">
            <summary>
            Gets <see cref="T:Arbor.Node" /> from the node identifier.
            </summary>
            <param name="nodeID">The node identifier.</param>
            <returns>Found <see cref = "T:Arbor.Node" />. Returns null if not found.</returns>
        </member>
        <member name="P:Arbor.NodeGraph.calculatorCount">
            <summary>
             Get a count of CalculatorNode.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.GetCalculatorFromIndex(System.Int32)">
            <summary>
            Get CalculatorNode from index.
            </summary>
            <param name="index">Index</param>
            <returns>CalculatorNode</returns>
        </member>
        <member name="M:Arbor.NodeGraph.GetCalculatorIndex(Arbor.CalculatorNode)">
            <summary>
            Get CalculatorNode index.
            </summary>
            <param name="calculator">CalculatorNode</param>
            <returns>Index. If not, it returns -1.</returns>
        </member>
        <member name="P:Arbor.NodeGraph.calculators">
            <summary>
            Gets all of <see cref = "T:Arbor.CalculatorNode" />.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.GetCalculatorFromID(System.Int32)">
            <summary>
            Gets <see cref="T:Arbor.CalculatorNode" /> from the calculator identifier.
            </summary>
            <param name="calculatorID">The calculator identifier.</param>
            <returns>Found <see cref = "T:Arbor.CalculatorNode" />. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.CreateCalculator(System.Int32,System.Type)">
            <summary>
            Create calculator.
            </summary>
            <param name="nodeID">Node ID</param>
            <param name="calculatorType">Calculator type</param>
            <returns>The created calculator. If the node ID is not unique, return null without creating it.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.CreateCalculator(System.Type)">
            <summary>
            Create calculator.
            </summary>
            <param name="calculatorType">Calculator type</param>
            <returns>The created calculator.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.FindCalculator(Arbor.Calculator)">
            <summary>
            Acquisition of CalculatorNodes Calculator belongs.
            </summary>
            <param name="calculator">Calculator</param>
            <returns>CalculatorNodes Calculator belongs. Return null if not.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.DeleteCalculator(Arbor.CalculatorNode)">
            <summary>
            Delete calculator.
            </summary>
            <param name="calculatorNode">Calculator that you want to delete.</param>
            <returns>true if deleted</returns>
        </member>
        <member name="P:Arbor.NodeGraph.commentCount">
            <summary>
             Get a count of CommentNode.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.GetCommentFromIndex(System.Int32)">
            <summary>
            Get CommentNode from index.
            </summary>
            <param name="index">Index</param>
            <returns>CommentNode</returns>
        </member>
        <member name="M:Arbor.NodeGraph.GetCommentIndex(Arbor.CommentNode)">
            <summary>
            Get CommentNode index.
            </summary>
            <param name="comment">CommentNode</param>
            <returns>Index. If not, it returns -1.</returns>
        </member>
        <member name="P:Arbor.NodeGraph.comments">
            <summary>
            Gets all of <see cref = "T:Arbor.CommentNode" />.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.GetCommentFromID(System.Int32)">
            <summary>
            Gets <see cref="T:Arbor.CommentNode" /> from the comment identifier.
            </summary>
            <param name="commentID">The comment identifier.</param>
            <returns>Found <see cref = "T:Arbor.CommentNode" />. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.CreateComment(System.Int32)">
            <summary>
            Create comment.
            </summary>
            <param name="nodeID">Node ID</param>
            <returns>The created comment. If the node ID is not unique, return null without creating it.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.CreateComment">
            <summary>
            Create comment.
            </summary>
            <returns>The created comment.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.DeleteComment(Arbor.CommentNode)">
            <summary>
            Delete comment.
            </summary>
            <param name="comment">Comment that you want to delete.</param>
        </member>
        <member name="P:Arbor.NodeGraph.groupCount">
            <summary>
             Get a count of GroupNode.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.GetGroupFromIndex(System.Int32)">
            <summary>
            Get GroupNode from index.
            </summary>
            <param name="index">Index</param>
            <returns>GroupNode</returns>
        </member>
        <member name="M:Arbor.NodeGraph.CreateGroup(System.Int32)">
            <summary>
            Create group.
            </summary>
            <param name="nodeID">Node ID</param>
            <returns>The created group. If the node ID is not unique, return null without creating it.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.CreateGroup">
            <summary>
            Create group.
            </summary>
            <returns>The created group.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.DeleteGroup(Arbor.GroupNode)">
            <summary>
            Delete group.
            </summary>
            <param name="group">Group that you want to delete.</param>
        </member>
        <member name="M:Arbor.NodeGraph.GetGroupFromID(System.Int32)">
            <summary>
            Gets <see cref="T:Arbor.GroupNode" /> from the group identifier.
            </summary>
            <param name="groupID">The group identifier.</param>
            <returns>Found <see cref = "T:Arbor.GroupNode" />. Returns null if not found.</returns>
        </member>
        <member name="P:Arbor.NodeGraph.dataBranchRerouteNodes">
            <summary>
            DataBranchRerouteNode list
            </summary>
        </member>
        <member name="P:Arbor.NodeGraph.calculatorBranchRerouteNodes">
            <summary>
            DataBranchRerouteNode list
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.CreateDataBranchRerouteNode(UnityEngine.Vector2,System.Type,System.Int32)">
            <summary>
            Create DataBranchRerouteNode.
            </summary>
            <param name="position">Position of the node</param>
            <param name="type">Value type</param>
            <param name="nodeID">Node ID</param>
            <returns>The created DataBranchRerouteNode. If the node ID is not unique, return null without creating it.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.CreateCalculatorBranchRerouteNode(UnityEngine.Vector2,System.Type,System.Int32)">
            <summary>
            Create DataBranchRerouteNode.
            </summary>
            <param name="position">Position of the node</param>
            <param name="type">Value type</param>
            <param name="nodeID">Node ID</param>
            <returns>The created DataBranchRerouteNode. If the node ID is not unique, return null without creating it.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.CreateDataBranchRerouteNode(UnityEngine.Vector2,System.Type)">
            <summary>
            Create DataBranchRerouteNode.
            </summary>
            <returns>The created DataBranchRerouteNode.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.CreateCalculatorBranchRerouteNode(UnityEngine.Vector2,System.Type)">
            <summary>
            Create DataBranchRerouteNode.
            </summary>
            <returns>The created DataBranchRerouteNode.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.DeleteDataBranchRerouteNode(Arbor.DataBranchRerouteNode)">
            <summary>
            Delete DataBranchRerouteNode.
            </summary>
            <param name="rerouteNode">DataBranchRerouteNode that you want to delete.</param>
        </member>
        <member name="M:Arbor.NodeGraph.DeleteCalculatorBranchRerouteNode(Arbor.DataBranchRerouteNode)">
            <summary>
            Delete DataBranchRerouteNode.
            </summary>
            <param name="rerouteNode">DataBranchRerouteNode that you want to delete.</param>
        </member>
        <member name="M:Arbor.NodeGraph.OnDeleteNode(Arbor.Node)">
            <summary>
            Delete node.
            </summary>
            <param name="node">The node to delete</param>
            <returns>Returns true if deleted, false otherwise.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.OnValidateNodes">
            <summary>
            Called when the node is changed.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.DeleteNode(Arbor.Node)">
            <summary>
            Delete node.
            </summary>
            <param name="node">Node that you want to delete.</param>
            <returns>true if deleted</returns>
        </member>
        <member name="M:Arbor.NodeGraph.OnValidate">
            <summary>
            See MonoBehaviour.OnValidate.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.FindNodeContainsBehaviour(Arbor.NodeBehaviour)">
            <summary>
            Acquisition of nodes NodeBehaviour belongs.
            </summary>
            <param name="behaviour">NodeBehaviour</param>
            <returns>Nodess NodeBehaviour belongs. Return null if not.</returns>
        </member>
        <member name="P:Arbor.NodeGraph.dataBranchCount">
            <summary>
             Get a count of DataBranch.
            </summary>
        </member>
        <member name="P:Arbor.NodeGraph.calculatorBranchCount">
            <summary>
             Get a count of DataBranch.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.GetDataBranchFromIndex(System.Int32)">
            <summary>
            Get DataBranch from index.
            </summary>
            <param name="index">Index</param>
            <returns>DataBranch</returns>
        </member>
        <member name="M:Arbor.NodeGraph.GetCalculatorBranchFromIndex(System.Int32)">
            <summary>
            Get DataBranch from index.
            </summary>
            <param name="index">Index</param>
            <returns>DataBranch</returns>
        </member>
        <member name="M:Arbor.NodeGraph.GetDataBranchIndex(Arbor.DataBranch)">
            <summary>
            Get DataBranch index.
            </summary>
            <param name="branch">DataBranch</param>
            <returns>Index. If not, it returns -1.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.GetCalculatorBranchIndex(Arbor.DataBranch)">
            <summary>
            Get DataBranch index.
            </summary>
            <param name="branch">DataBranch</param>
            <returns>Index. If not, it returns -1.</returns>
        </member>
        <member name="P:Arbor.NodeGraph.calculatorBranchies">
            <summary>
            Gets all of <see cref = "T:Arbor.DataBranch" />.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.GetDataBranchFromID(System.Int32)">
            <summary>
            Gets <see cref="T:Arbor.DataBranch" /> from the calculator branch identifier.
            </summary>
            <param name="branchID">The calculator branch identifier.</param>
            <returns>Found <see cref = "T:Arbor.DataBranch" />. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.GetCalculatorBranchFromID(System.Int32)">
            <summary>
            Gets <see cref="T:Arbor.DataBranch" /> from the calculator branch identifier.
            </summary>
            <param name="branchID">The calculator branch identifier.</param>
            <returns>Found <see cref = "T:Arbor.DataBranch" />. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.ConnectDataBranch(System.Int32,System.Int32,UnityEngine.Object,Arbor.DataSlot,System.Int32,UnityEngine.Object,Arbor.DataSlot)">
            <summary>
            Connect DataSlot.
            </summary>
            <param name="branchID">ID of the DataBranch to be created</param>
            <param name="inputNodeID">Input node ID.</param>
            <param name="inputObj">Input object.</param>
            <param name="inputSlot">Input slot.</param>
            <param name="outputNodeID">Output node ID.</param>
            <param name="outputObj">Output object.</param>
            <param name="outputSlot">Output slot.</param>
            <returns>Connected DataBranch</returns>
        </member>
        <member name="M:Arbor.NodeGraph.ConnectCalculatorBranch(System.Int32,System.Int32,UnityEngine.Object,Arbor.DataSlot,System.Int32,UnityEngine.Object,Arbor.DataSlot)">
            <summary>
            Connect DataSlot.
            </summary>
            <param name="branchID">ID of the DataBranch to be created</param>
            <param name="inputNodeID">Input node ID.</param>
            <param name="inputObj">Input object.</param>
            <param name="inputSlot">Input slot.</param>
            <param name="outputNodeID">Output node ID.</param>
            <param name="outputObj">Output object.</param>
            <param name="outputSlot">Output slot.</param>
            <returns>Connected DataBranch</returns>
        </member>
        <member name="M:Arbor.NodeGraph.ConnectDataBranch(System.Int32,UnityEngine.Object,Arbor.DataSlot,System.Int32,UnityEngine.Object,Arbor.DataSlot)">
            <summary>
            Connect DataSlot.
            </summary>
            <param name="inputNodeID">Input node ID.</param>
            <param name="inputObj">Input object.</param>
            <param name="inputSlot">Input slot.</param>
            <param name="outputNodeID">Output node ID.</param>
            <param name="outputObj">Output object.</param>
            <param name="outputSlot">Output slot.</param>
            <returns>Connected DataBranch</returns>
        </member>
        <member name="M:Arbor.NodeGraph.ConnectCalculatorBranch(System.Int32,UnityEngine.Object,Arbor.DataSlot,System.Int32,UnityEngine.Object,Arbor.DataSlot)">
            <summary>
            Connect DataSlot.
            </summary>
            <param name="inputNodeID">Input node ID.</param>
            <param name="inputObj">Input object.</param>
            <param name="inputSlot">Input slot.</param>
            <param name="outputNodeID">Output node ID.</param>
            <param name="outputObj">Output object.</param>
            <param name="outputSlot">Output slot.</param>
            <returns>Connected DataBranch</returns>
        </member>
        <member name="M:Arbor.NodeGraph.DisconnectDataBranch(UnityEngine.Object)">
            <summary>
            Method to be used internally. In particular there is no need to call.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.DeleteDataBranch(Arbor.DataBranch)">
            <summary>
            Delete DataBranch.
            </summary>
            <param name="branch">DataBranch that you want to delete.</param>
        </member>
        <member name="M:Arbor.NodeGraph.DeleteCalculatorBranch(Arbor.DataBranch)">
            <summary>
            Delete DataBranch.
            </summary>
            <param name="branch">DataBranch that you want to delete.</param>
        </member>
        <member name="M:Arbor.NodeGraph.FindGraph(System.String)">
            <summary>
            Get the NodeGraph that in the scene with the name.
            </summary>
            <param name="name">The name of the search NodeGraph.</param>
            <returns>Found NodeGraph. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.FindGraph(System.String,System.Type)">
            <summary>
            Get the NodeGraph that in the scene with the name.
            </summary>
            <param name="name">The name of the search NodeGraph.</param>
            <param name="type">The type of the search NodeGraph.</param>
            <returns>Found NodeGraph. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.FindGraph``1(System.String)">
            <summary>
            Get the NodeGraph that in the scene with the name.
            </summary>
            <typeparam name="T">The type of the search NodeGraph.</typeparam>
            <param name="name">The name of the search NodeGraph.</param>
            <returns>Found NodeGraph. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.FindGraphs(System.String)">
            <summary>
            Get the NodeGraph of the same name that is in the scene.
            </summary>
            <param name="name">The name of the search NodeGraph.</param>
            <returns>Array of found NodeGraph.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.FindGraphs(System.String,System.Type)">
            <summary>
            Get the NodeGraph of the same name that is in the scene.
            </summary>
            <param name="name">The name of the search NodeGraph.</param>
            <param name="type">The type of the search NodeGraph.</param>
            <returns>Array of found NodeGraph.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.FindGraphs``1(System.String)">
            <summary>
            Get the NodeGraph of the same name that is in the scene.
            </summary>
            <typeparam name="T">The type of the search NodeGraph.</typeparam>
            <param name="name">The name of the search NodeGraph.</param>
            <returns>Array of found NodeGraph.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.FindGraph(UnityEngine.GameObject,System.String)">
            <summary>
            Get NodeGraph in the name that has been attached to the GameObject.
            </summary>
            <param name="gameObject">Want to search GameObject.</param>
            <param name="name">The name of the search NodeGraph.</param>
            <returns>Found NodeGraph. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.FindGraph(UnityEngine.GameObject,System.String,System.Type)">
            <summary>
            Get NodeGraph in the name that has been attached to the GameObject.
            </summary>
            <param name="gameObject">Want to search GameObject.</param>
            <param name="name">The name of the search NodeGraph.</param>
            <param name="type">The type of the search NodeGraph.</param>
            <returns>Found NodeGraph. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.FindGraph``1(UnityEngine.GameObject,System.String)">
            <summary>
            Get NodeGraph in the name that has been attached to the GameObject.
            </summary>
            <typeparam name="T">The type of the search NodeGraph.</typeparam>
            <param name="gameObject">Want to search GameObject.</param>
            <param name="name">The name of the search NodeGraph.</param>
            <returns>Found NodeGraph. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.FindGraphs(UnityEngine.GameObject,System.String)">
            <summary>
            Get the NodeGraph of the same name that is attached to a GameObject.
            </summary>
            <param name="gameObject">Want to search GameObject.</param>
            <param name="name">The name of the search NodeGraph.</param>
            <returns>Array of found NodeGraph.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.FindGraphs(UnityEngine.GameObject,System.String,System.Type)">
            <summary>
            Get the NodeGraph of the same name that is attached to a GameObject.
            </summary>
            <param name="gameObject">Want to search GameObject.</param>
            <param name="name">The name of the search NodeGraph.</param>
            <param name="type">The type of the search NodeGraph.</param>
            <returns>Array of found NodeGraph.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.FindGraphs``1(UnityEngine.GameObject,System.String)">
            <summary>
            Get the NodeGraph of the same name that is attached to a GameObject.
            </summary>
            <typeparam name="T">The type of the search NodeGraph.</typeparam>
            <param name="gameObject">Want to search GameObject.</param>
            <param name="name">The name of the search NodeGraph.</param>
            <returns>Array of found NodeGraph.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.CheckLoopDataBranch(System.Int32,UnityEngine.Object,System.Int32,UnityEngine.Object)">
            <summary>
            Check if DataBranch is looping.
            </summary>
            <param name="inputNodeID">Input slot side node ID</param>
            <param name="inputObj">Input slot side Object</param>
            <param name="outputNodeID">Output slot side node ID</param>
            <param name="outputObj">Output slot side Object</param>
            <returns>Returns true if it is looping.</returns>
        </member>
        <member name="M:Arbor.NodeGraph.CheckLoopCalculatorBranch(System.Int32,UnityEngine.Object,System.Int32,UnityEngine.Object)">
            <summary>
            Check if DataBranch is looping.
            </summary>
            <param name="inputNodeID">Input slot side node ID</param>
            <param name="inputObj">Input slot side Object</param>
            <param name="outputNodeID">Output slot side node ID</param>
            <param name="outputObj">Output slot side Object</param>
            <returns>Returns true if it is looping.</returns>
        </member>
        <member name="T:Arbor.NodeGraph.NodeGraphCallback">
            <summary>
            Delegate for NodeGraph callback
            </summary>
            <param name="nodeGraph">Event occurred NodeGraph</param>
        </member>
        <member name="E:Arbor.NodeGraph.destroyCallback">
            <summary>
            Call back when being destroyed
            </summary>
        </member>
        <member name="E:Arbor.NodeGraph.stateChangedCallback">
            <summary>
            Call back when the state changes
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.DestroySubComponents">
            <summary>
            Method to be used internally. In particular there is no need to call.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.OnReset">
            <summary>
            Reset or create callback.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.Create(UnityEngine.GameObject,System.Type)">
            <summary>
            Create NodeGraph
            </summary>
            <param name="gameObject">GameObject</param>
            <param name="classType">NodeGraph type</param>
            <returns>The created NodeGraph</returns>
        </member>
        <member name="M:Arbor.NodeGraph.Create``1(UnityEngine.GameObject)">
            <summary>
            Create NodeGraph
            </summary>
            <typeparam name="GraphType">NodeGraph type</typeparam>
            <param name="gameObject">GameObject</param>
            <returns>The created NodeGraph</returns>
        </member>
        <member name="M:Arbor.NodeGraph.Instantiate(Arbor.NodeGraph,Arbor.NodeBehaviour,System.Boolean)">
            <summary>
            Instantiate NodeGraph
            </summary>
            <param name="sourceGraph">Source graph</param>
            <param name="ownerBehaviour">NodeBehaviour with chart ownership</param>
            <param name="usePool">Flag to instantiate using ObjectPool.</param>
            <returns>Instantiated graph</returns>
        </member>
        <member name="M:Arbor.NodeGraph.Instantiate``1(``0,Arbor.NodeBehaviour,System.Boolean)">
            <summary>
            Instantiate NodeGraph
            </summary>
            <typeparam name="GraphType">Graph type</typeparam>
            <param name="sourceGraph">Source graph</param>
            <param name="ownerBehaviour">NodeBehaviour with chart ownership</param>
            <param name="usePool">Flag to instantiate using ObjectPool.</param>
            <returns>Instantiated graph</returns>
        </member>
        <member name="M:Arbor.NodeGraph.Destroy(Arbor.NodeGraph)">
            <summary>
            Destroy NodeGraph
            </summary>
            <param name="nodeGraph">NodeGraph</param>
        </member>
        <member name="M:Arbor.NodeGraph.ToString">
            <summary>
            Convert graph to string (for debugging).
            </summary>
            <returns>Converted string</returns>
        </member>
        <member name="M:Arbor.NodeGraph.OnPoolResume">
            <summary>
            Called when resuming.
            </summary>
        </member>
        <member name="M:Arbor.NodeGraph.OnPoolSleep">
            <summary>
            Called when stored in the pool.
            </summary>
        </member>
        <member name="T:Arbor.NodeList`1">
            <summary>
            Node list
            </summary>
            <typeparam name="T">Node type</typeparam>
        </member>
        <member name="P:Arbor.NodeList`1.count">
            <summary>
             Get a count of Node.
            </summary>
        </member>
        <member name="P:Arbor.NodeList`1.Item(System.Int32)">
            <summary>
            Get Node from index.
            </summary>
            <param name="index">Index</param>
        </member>
        <member name="M:Arbor.NodeList`1.IndexOf(`0)">
            <summary>
            Get Node index.
            </summary>
            <param name="node">Node</param>
            <returns>Index. If not, it returns -1.</returns>
        </member>
        <member name="M:Arbor.NodeList`1.GetFromID(System.Int32)">
            <summary>
            Gets Node from the node identifier.
            </summary>
            <param name="nodeID">The node identifier.</param>
            <returns>Found Node. Returns null if not found.</returns>
        </member>
        <member name="M:Arbor.NodeList`1.Add(`0)">
            <summary>
            Add a node.
            </summary>
            <param name="node">The node to be added.</param>
        </member>
        <member name="M:Arbor.NodeList`1.Remove(`0)">
            <summary>
            Remove a node.
            </summary>
            <param name="node">The node to be removed.</param>
            <returns>Returns true if removed.</returns>
        </member>
        <member name="T:Arbor.ObjectPooling.IPoolCallbackReceiver">
            <summary>
            Interface receiving ObjectPool callback
            </summary>
            <remarks>You can receive callbacks by defining this interface for MonoBehaviour added to the game object under pool management (including child).</remarks>
        </member>
        <member name="M:Arbor.ObjectPooling.IPoolCallbackReceiver.OnPoolResume">
            <summary>
            Called when resuming.
            </summary>
        </member>
        <member name="M:Arbor.ObjectPooling.IPoolCallbackReceiver.OnPoolSleep">
            <summary>
            Called when stored in the pool.
            </summary>
        </member>
        <member name="T:Arbor.ObjectPooling.ObjectPool">
            <summary>
            ObjectPool management class
            </summary>
        </member>
        <member name="P:Arbor.ObjectPooling.ObjectPool.advancedRatePerFrame">
            <summary>
            Advanced Pooling processing frame rate (multiplication factor relative to the screen refresh rate)
            </summary>
            <remarks>
            If processing time is exceeded beyond this frame rate, it waits until the next frame.<br/>
            The default value is 10.<br/>
            If 0 or less is specified, use <see cref="P:Arbor.ObjectPooling.ObjectPool.advancedFrameRate"/>.
            </remarks>
        </member>
        <member name="P:Arbor.ObjectPooling.ObjectPool.advancedFrameRate">
            <summary>
            Advanced Pooling processing frame rate
            </summary>
            <remarks>
            If processing time is exceeded beyond this frame rate, it waits until the next frame.<br/>
            When 0 or less is specified for both advancedFrameRate and <see cref="P:Arbor.ObjectPooling.ObjectPool.advancedRatePerFrame"/>, do not wait until all pools are completed.<br/>
            The default value is 0.<br/>
            </remarks>
        </member>
        <member name="P:Arbor.ObjectPooling.ObjectPool.isReady">
            <summary>
            Returns whether Advanced pooling is completed.
            </summary>
        </member>
        <member name="M:Arbor.ObjectPooling.ObjectPool.AdvancedPool(System.Collections.Generic.IEnumerable{Arbor.ObjectPooling.PoolingItem})">
            <summary>
            Pool in advance.
            </summary>
            <param name="items">List of objects to pool</param>
        </member>
        <member name="M:Arbor.ObjectPooling.ObjectPool.Instantiate(UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            Instantiate an object.
            </summary>
            <param name="original">Original object</param>
            <param name="position">Position</param>
            <param name="rotation">Rotation</param>
            <returns>Instantiated object</returns>
            <remarks>
            If there is a pooled object, resume that object.<br/>
            If there is no pool, it is newly instantiated by Object.Instantiate.
            </remarks>
        </member>
        <member name="M:Arbor.ObjectPooling.ObjectPool.Instantiate(UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Transform)">
            <summary>
            Instantiate an object.
            </summary>
            <param name="original">Original object</param>
            <param name="position">Position</param>
            <param name="rotation">Rotation</param>
            <param name="parent">Parent Transform</param>
            <returns>Instantiated object</returns>
            <remarks>
            If there is a pooled object, resume that object.<br/>
            If there is no pool, it is newly instantiated by Object.Instantiate.
            </remarks>
        </member>
        <member name="M:Arbor.ObjectPooling.ObjectPool.Instantiate(UnityEngine.Object)">
            <summary>
            Instantiate an object.
            </summary>
            <param name="original">Original object</param>
            <returns>Instantiated object</returns>
            <remarks>
            If there is a pooled object, resume that object.<br/>
            If there is no pool, it is newly instantiated by Object.Instantiate.
            </remarks>
        </member>
        <member name="M:Arbor.ObjectPooling.ObjectPool.Instantiate(UnityEngine.Object,UnityEngine.Transform)">
            <summary>
            Instantiate an object.
            </summary>
            <param name="original">Original object</param>
            <param name="parent">Parent Transform</param>
            <returns>Instantiated object</returns>
            <remarks>
            If there is a pooled object, resume that object.<br/>
            If there is no pool, it is newly instantiated by Object.Instantiate.
            </remarks>
        </member>
        <member name="M:Arbor.ObjectPooling.ObjectPool.Instantiate(UnityEngine.Object,UnityEngine.Transform,System.Boolean)">
            <summary>
            Instantiate an object.
            </summary>
            <param name="original">Original object</param>
            <param name="parent">Parent Transform</param>
            <param name="instantiateInWorldSpace">If when assigning the parent the original world position should be maintained.</param>
            <returns>Instantiated object</returns>
            <remarks>
            If there is a pooled object, resume that object.<br/>
            If there is no pool, it is newly instantiated by Object.Instantiate.
            </remarks>
        </member>
        <member name="M:Arbor.ObjectPooling.ObjectPool.Instantiate``1(``0)">
            <summary>
            Instantiate an object.
            </summary>
            <typeparam name="T">Object type</typeparam>
            <param name="original">Original object</param>
            <returns>Instantiated object</returns>
            <remarks>
            If there is a pooled object, resume that object.<br/>
            If there is no pool, it is newly instantiated by Object.Instantiate.
            </remarks>
        </member>
        <member name="M:Arbor.ObjectPooling.ObjectPool.Instantiate``1(``0,UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            Instantiate an object.
            </summary>
            <typeparam name="T">Object type</typeparam>
            <param name="original">Original object</param>
            <param name="position">Position</param>
            <param name="rotation">Rotation</param>
            <returns>Instantiated object</returns>
            <remarks>
            If there is a pooled object, resume that object.<br/>
            If there is no pool, it is newly instantiated by Object.Instantiate.
            </remarks>
        </member>
        <member name="M:Arbor.ObjectPooling.ObjectPool.Instantiate``1(``0,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Transform)">
            <summary>
            Instantiate an object.
            </summary>
            <typeparam name="T">Object type</typeparam>
            <param name="original">Original object</param>
            <param name="position">Position</param>
            <param name="rotation">Rotation</param>
            <param name="parent">Parent Transform</param>
            <returns>Instantiated object</returns>
            <remarks>
            If there is a pooled object, resume that object.<br/>
            If there is no pool, it is newly instantiated by Object.Instantiate.
            </remarks>
        </member>
        <member name="M:Arbor.ObjectPooling.ObjectPool.Instantiate``1(``0,UnityEngine.Transform)">
            <summary>
            Instantiate an object.
            </summary>
            <typeparam name="T">Object type</typeparam>
            <param name="original">Original object</param>
            <param name="parent">Parent Transform</param>
            <returns>Instantiated object</returns>
            <remarks>
            If there is a pooled object, resume that object.<br/>
            If there is no pool, it is newly instantiated by Object.Instantiate.
            </remarks>
        </member>
        <member name="M:Arbor.ObjectPooling.ObjectPool.Instantiate``1(``0,UnityEngine.Transform,System.Boolean)">
            <summary>
            Instantiate an object.
            </summary>
            <typeparam name="T">Object type</typeparam>
            <param name="original">Original object</param>
            <param name="parent">Parent Transform</param>
            <param name="instantiateInWorldSpace">If when assigning the parent the original world position should be maintained.</param>
            <returns>Instantiated object</returns>
            <remarks>
            If there is a pooled object, resume that object.<br/>
            If there is no pool, it is newly instantiated by Object.Instantiate.
            </remarks>
        </member>
        <member name="M:Arbor.ObjectPooling.ObjectPool.Destroy(UnityEngine.GameObject)">
            <summary>
            Destroy GameObject.
            </summary>
            <param name="gameObject">GameObject to destroy</param>
            <remarks>
            If it is a GameObject under pool management, return it to the pool.<br/>
            If it is not under management, it is destroyed by Object.Destroy.<br/>
            </remarks>
        </member>
        <member name="M:Arbor.ObjectPooling.ObjectPool.DestroyImmediate(UnityEngine.GameObject)">
            <summary>
            Destroy GameObject immediately.
            </summary>
            <param name="gameObject">GameObject to destroy</param>
            <remarks>
            If it is a GameObject under pool management, return it to the pool.<br/>
            If it is not under management, it is destroyed by Object.DestroyImmediate.<br/>
            </remarks>
        </member>
        <member name="T:Arbor.ObjectPooling.PoolingItem">
            <summary>
            Class for setting the object to the pool in advance
            </summary>
        </member>
        <member name="F:Arbor.ObjectPooling.PoolingItem._Type">
            <summary>
            Object type
            </summary>
        </member>
        <member name="F:Arbor.ObjectPooling.PoolingItem.original">
            <summary>
            Original object
            </summary>
        </member>
        <member name="F:Arbor.ObjectPooling.PoolingItem.amount">
            <summary>
            Amount to pool
            </summary>
        </member>
        <member name="P:Arbor.ObjectPooling.PoolingItem.type">
            <summary>
            Object type
            </summary>
        </member>
        <member name="M:Arbor.ObjectPooling.PoolingItem.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Arbor.ObjectPooling.PoolingItem.#ctor(UnityEngine.Object,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="original">Original object</param>
            <param name="amount">Amount to pool</param>
        </member>
        <member name="M:Arbor.ObjectPooling.PoolingItem.#ctor(Arbor.ObjectPooling.PoolingItem)">
            <summary>
            Copy constructor
            </summary>
            <param name="item">Copy PoolingItem</param>
        </member>
        <member name="T:Arbor.ObjectPooling.PoolingItemList">
            <summary>
            List of objects to pool
            </summary>
        </member>
        <member name="M:Arbor.ObjectPooling.PoolingItemList.AdvancedPool">
            <summary>
            Pool in advance.
            </summary>
        </member>
        <member name="T:Arbor.Parameter">
            <summary>
            Class of Parameter to be stored in the ParameterContainer.
            </summary>
        </member>
        <member name="T:Arbor.Parameter.DelegateOnChanged">
            <summary>
            Delegate called when changing Parameter.
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="T:Arbor.Parameter.Type">
            <summary>
            Parameter type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Int">
            <summary>
            Int type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Float">
            <summary>
            Float type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Bool">
            <summary>
            Bool type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.GameObject">
            <summary>
            GameObject type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.String">
            <summary>
            String type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Enum">
            <summary>
            Enum type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Vector2">
            <summary>
            Vector2 type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Vector3">
            <summary>
            Vector3 type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Quaternion">
            <summary>
            Quaternion type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Rect">
            <summary>
            Rect type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Bounds">
            <summary>
            Bounds type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Color">
            <summary>
            Color type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Transform">
            <summary>
            Transform type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.RectTransform">
            <summary>
            RectTransform type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Rigidbody">
            <summary>
            Rigidbody type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Rigidbody2D">
            <summary>
            Rigidbody2D type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Component">
            <summary>
            Component type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Long">
            <summary>
            Long type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.Type.Variable">
            <summary>
            Variable type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.container">
            <summary>
            Container this parameter is stored.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.id">
            <summary>
            ID.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.type">
            <summary>
            Type.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.name">
            <summary>
            Name.
            </summary>
        </member>
        <member name="F:Arbor.Parameter.referenceType">
            <summary>
            the type of objectReferenceValue and Enum.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.componentType">
            <summary>
            Component type
            </summary>
        </member>
        <member name="P:Arbor.Parameter.isPublicSet">
            <summary>
            Returns whether this parameter can be set from an external graph. (For parameters in graph)
            </summary>
        </member>
        <member name="P:Arbor.Parameter.isPublicGet">
            <summary>
            Returns whether this parameter can be get from an external graph. (For parameters in graph)
            </summary>
        </member>
        <member name="P:Arbor.Parameter.intValue">
            <summary>
            Value of Int type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.longValue">
            <summary>
            Value of Long type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.floatValue">
            <summary>
            Value of Float type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.boolValue">
            <summary>
            Value of Bool type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.stringValue">
            <summary>
            Value of String type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.isEnum">
            <summary>
            Returns whether this parameter is of type Enum.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.enumValue">
            <summary>
            Value of Enum type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.vector2Value">
            <summary>
            Value of Vector2 type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.vector3Value">
            <summary>
            Value of Vector3 type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.quaternionValue">
            <summary>
            Value of Quaternion type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.rectValue">
            <summary>
            Value of Rect type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.boundsValue">
            <summary>
            Value of Bounds type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.colorValue">
            <summary>
            Value of Color type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.objectReferenceValue">
            <summary>
            Value of Object type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.gameObjectValue">
            <summary>
            Value of GameObject type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.variableValue">
            <summary>
            Value of Variable type.
            </summary>
        </member>
        <member name="M:Arbor.Parameter.GetValueType(Arbor.Parameter.Type,System.Type)">
            <summary>
            Get the value type of the parameter.
            </summary>
            <param name="type">Type of parameter</param>
            <param name="referenceType">Reference type (used for Enum, Component, Variable)</param>
            <returns>Value type of the parameter</returns>
        </member>
        <member name="P:Arbor.Parameter.valueType">
            <summary>
            Get value type.
            </summary>
        </member>
        <member name="P:Arbor.Parameter.value">
            <summary>
            Get values according to type.
            </summary>
        </member>
        <member name="E:Arbor.Parameter.onChanged">
            <summary>
            Callback function to be called when the value is changed.
            </summary>
        </member>
        <member name="M:Arbor.Parameter.OnChanged">
            <summary>
            Call when you change the value.
            </summary>
        </member>
        <member name="M:Arbor.Parameter.SetEnum``1(``0)">
            <summary>
            Set Enum value
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.Parameter.TryGetEnum``1(``0@)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="value">The value you get.</param>
            <returns>Returns true if it succeeds.</returns>
        </member>
        <member name="M:Arbor.Parameter.SetVariable``1(``0)">
            <summary>
            Set Variable value
            </summary>
            <typeparam name="T">Variable value Type</typeparam>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.Parameter.GetVariable``1(``0@)">
            <summary>
            Get Variable value
            </summary>
            <typeparam name="T">Variable value type</typeparam>
            <param name="value">Value</param>
            <returns>Succeeds if true, failure if false</returns>
        </member>
        <member name="M:Arbor.Parameter.ToString">
            <summary>
            Convert value to string format.
            </summary>
            <returns>Converted string</returns>
        </member>
        <member name="M:Arbor.Parameter.ToString(System.String)">
            <summary>
            Convert value to string format.
            </summary>
            <param name="format">Numeric format string (Int, Long, Float only)</param>
            <returns>Converted string</returns>
            <remarks>For more information about numeric format specifiers, see <a href="https://msdn.microsoft.com/en-us/library/dwhawy9k(v=vs.110).aspx">Standard Numeric Format Strings</a> and <a href="https://msdn.microsoft.com/en-us/library/0c899ak8(v=vs.110).aspx">Custom Numeric Format Strings</a>.</remarks>
        </member>
        <member name="M:Arbor.Parameter.ChangeContainer(Arbor.ParameterContainerInternal)">
            <summary>
            For Editor.
            </summary>
        </member>
        <member name="T:Arbor.ParameterBehaviours.SetParameterBehaviourInternal">
            <summary>
            Internal class of <see cref="!:Arbor.ParameterBehaviours.SetParameterBehaviour" />.
            </summary>
        </member>
        <member name="F:Arbor.ParameterBehaviours.SetParameterBehaviourInternal._ParameterReference">
            <summary>
            Setting destination parameter.
            </summary>
        </member>
        <member name="F:Arbor.ParameterBehaviours.SetParameterBehaviourInternal._Input">
            <summary>
            Data input slot of the value to be set.
            </summary>
        </member>
        <member name="M:Arbor.ParameterBehaviours.SetParameterBehaviourInternal.SetParameter(Arbor.Parameter)">
            <summary>
            Set parameter.
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.ParameterBehaviours.SetParameterBehaviourInternal.OnStateBegin">
            <summary>
            Called when [state enter].
            </summary>
        </member>
        <member name="T:Arbor.ParameterBehaviours.SetParameterActionInternal">
            <summary>
            Internal class of <see cref="!:Arbor.ParameterBehaviours.SetParameterAction" />.
            </summary>
        </member>
        <member name="F:Arbor.ParameterBehaviours.SetParameterActionInternal._ParameterReference">
            <summary>
            Setting destination parameter.
            </summary>
        </member>
        <member name="F:Arbor.ParameterBehaviours.SetParameterActionInternal._Input">
            <summary>
            Data input slot of the value to be set.
            </summary>
        </member>
        <member name="M:Arbor.ParameterBehaviours.SetParameterActionInternal.SetParameter(Arbor.Parameter)">
            <summary>
            Set parameter.
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.ParameterBehaviours.SetParameterActionInternal.OnExecute">
            <summary>
            Called when executing.
            </summary>
        </member>
        <member name="T:Arbor.ParameterBehaviours.GetParameterCalculatorInternal">
            <summary>
            Internal class of <see cref="!:Arbor.ParameterBehaviours.GetParameterCalculator" />.
            </summary>
        </member>
        <member name="F:Arbor.ParameterBehaviours.GetParameterCalculatorInternal._ParameterReference">
            <summary>
            Parameters to get.
            </summary>
        </member>
        <member name="F:Arbor.ParameterBehaviours.GetParameterCalculatorInternal._Output">
            <summary>
            A slot that outputs the value of the parameter.
            </summary>
        </member>
        <member name="M:Arbor.ParameterBehaviours.GetParameterCalculatorInternal.SetParameter(Arbor.Parameter)">
            <summary>
            Set parameter.
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.ParameterBehaviours.GetParameterCalculatorInternal.OnCalculate">
            <summary>
            It called when it is calculated .
            </summary>
        </member>
        <member name="T:Arbor.ParameterContainerBase">
            <summary>
            Base class to identify the ParameterContainer
            </summary>
        </member>
        <member name="P:Arbor.ParameterContainerBase.container">
            <summary>
            It returns the ParameterContainer entity.
            </summary>
        </member>
        <member name="P:Arbor.ParameterContainerBase.defaultContainer">
            <summary>
            It returns the original ParameterContainer.
            </summary>
        </member>
        <member name="T:Arbor.ParameterContainerInternal">
            <summary>
            ParameterContainer.
            Is used by attaching to GameObject.
            </summary>
        </member>
        <member name="F:Arbor.ParameterContainerInternal._Parameters">
            <summary>List of parameters.<br/>
            <list type="bullet">
            <item><description>From the + button, select the type of parameter to create.</description></item>
            <item><description>Select the parameter and delete it by clicking the - button.</description></item>
            </list>
            </summary>
        </member>
        <member name="P:Arbor.ParameterContainerInternal.parameters">
            <summary>
            Get an array of parameters.
            </summary>
        </member>
        <member name="P:Arbor.ParameterContainerInternal.parameterCount">
            <summary>
             Get a count of Parameter.
            </summary>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetParameterFromIndex(System.Int32)">
            <summary>
            Get Parameter from index.
            </summary>
            <param name="index">Index</param>
            <returns>Parameter</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.Refresh">
            <summary>
            Editor only
            </summary>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.AddParam(System.String,Arbor.Parameter.Type)">
            <summary>
            Add a parameter.
            </summary>
            <param name="name">Name. It is changed to a unique name if the name had been duplicated.</param>
            <param name="type">Type.</param>
            <returns>It added parameters.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetParam(System.String)">
            <summary>
            Get the parameters from the name.
            </summary>
            <param name="name">Name.</param>
            <returns>Parameters. Return null if you did not exist.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetParamID(System.String)">
            <summary>
            Get the parameters ID from the name.
            </summary>
            <param name="name">Name.</param>
            <returns>Parameters ID. Return 0 if you did not exist.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetParam(System.Int32)">
            <summary>
            Get the parameters from the ID.
            </summary>
            <param name="id">ID.</param>
            <returns>Parameters. Return null if you did not exist.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.DeleteParam(Arbor.Parameter)">
            <summary>
            Delete a parameter.
            </summary>
            <param name="parameter">Parameter.</param>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.DeleteParam(System.String)">
            <summary>
            Delete the parameters by name.
            </summary>
            <param name="name">Name.</param>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.DeleteParam(System.Int32)">
            <summary>
            Delete the parameters by ID.
            </summary>
            <param name="id">ID.</param>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.MakeUniqueName(System.String)">
            <summary>
            It generates a name that does not overlap.
            </summary>
            <param name="name">The original name.</param>
            <returns>Result.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.IsParameterType(System.String,Arbor.Parameter.Type)">
            <summary>
            Determine the type of parameter.
            </summary>
            <param name="name">Name.</param>
            <param name="type">Parameter type.</param>
            <returns>Returns true if the parameter type matches type.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.IsParameterType(System.Int32,Arbor.Parameter.Type)">
            <summary>
            Determine the type of parameter.
            </summary>
            <param name="id">ID.</param>
            <param name="type">Parameter type.</param>
            <returns>Returns true if the parameter type matches type.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetFloat(System.String,System.Single)">
            <summary>
            It wants to set the value of the Float type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetFloat(System.Int32,System.Single)">
            <summary>
            It wants to set the value of the Float type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetFloat(System.String,System.Single@)">
            <summary>
            Get the value of the Float type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetFloat(System.Int32,System.Single@)">
            <summary>
            Get the value of the Float type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetFloat(System.String,System.Single)">
            <summary>
            Get the value of the Float type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetFloat(System.Int32,System.Single)">
            <summary>
            Get the value of the Float type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetFloat(System.String,System.Single@)">
            <summary>
            Get the value of the Float type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetFloat(System.Int32,System.Single@)">
            <summary>
            Get the value of the Float type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetInt(System.String,System.Int32)">
            <summary>
            It wants to set the value of the Int type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetInt(System.Int32,System.Int32)">
            <summary>
            It wants to set the value of the Int type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetInt(System.String,System.Int32@)">
            <summary>
            Get the value of the Int type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetInt(System.Int32,System.Int32@)">
            <summary>
            Get the value of the Int type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetInt(System.Int32,System.Int32)">
            <summary>
            Get the value of the Int type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetInt(System.String,System.Int32)">
            <summary>
            Get the value of the Int type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetInt(System.String,System.Int32@)">
            <summary>
            Get the value of the Int type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetInt(System.Int32,System.Int32@)">
            <summary>
            Get the value of the Int type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetLong(System.String,System.Int64)">
            <summary>
            It wants to set the value of the Long type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetLong(System.Int32,System.Int64)">
            <summary>
            It wants to set the value of the Long type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetLong(System.String,System.Int64@)">
            <summary>
            Get the value of the Long type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetLong(System.Int32,System.Int64@)">
            <summary>
            Get the value of the Long type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetLong(System.String,System.Int64)">
            <summary>
            Get the value of the Long type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetLong(System.Int32,System.Int64)">
            <summary>
            Get the value of the Long type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetLong(System.String,System.Int64@)">
            <summary>
            Get the value of the Long type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetLong(System.Int32,System.Int64@)">
            <summary>
            Get the value of the Long type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetBool(System.String,System.Boolean)">
            <summary>
            It wants to set the value of the Bool type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetBool(System.Int32,System.Boolean)">
            <summary>
            It wants to set the value of the Bool type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetBool(System.String,System.Boolean@)">
            <summary>
            Get the value of the Bool type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetBool(System.Int32,System.Boolean@)">
            <summary>
            Get the value of the Bool type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetBool(System.String,System.Boolean)">
            <summary>
            Get the value of the Bool type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetBool(System.Int32,System.Boolean)">
            <summary>
            Get the value of the Bool type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetBool(System.String,System.Boolean@)">
            <summary>
            Get the value of the Bool type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetBool(System.Int32,System.Boolean@)">
            <summary>
            Get the value of the Bool type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetString(System.String,System.String)">
            <summary>
            It wants to set the value of the String type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetString(System.Int32,System.String)">
            <summary>
            It wants to set the value of the String type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetString(System.String,System.String@)">
            <summary>
            Get the value of the String type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetString(System.Int32,System.String@)">
            <summary>
            Get the value of the String type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetString(System.String,System.String)">
            <summary>
            Get the value of the String type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetString(System.Int32,System.String)">
            <summary>
            Get the value of the String type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetString(System.String,System.String@)">
            <summary>
            Get the value of the String type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetString(System.Int32,System.String@)">
            <summary>
            Get the value of the String type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.IsEnum(System.Int32)">
            <summary>
            It wants to set the value of the Enum type.
            </summary>
            <param name="id">ID.</param>
            <returns>Returns true if it is an Enum type.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.IsEnum(System.String)">
            <summary>
            It wants to set the value of the Enum type.
            </summary>
            <param name="name">Name.</param>
            <returns>Returns true if it is an Enum type.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetEnumInt(System.String,System.Int32)">
            <summary>
            It wants to set the value of the Enum type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetEnumInt(System.Int32,System.Int32)">
            <summary>
            It wants to set the value of the Enum type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetEnumInt(System.String,System.Int32@)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetEnumInt(System.Int32,System.Int32@)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetEnumInt(System.String,System.Int32)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetEnumInt(System.Int32,System.Int32)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetEnum(System.String,System.Enum)">
            <summary>
            It wants to set the value of the Enum type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetEnum(System.Int32,System.Enum)">
            <summary>
            It wants to set the value of the Enum type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetEnum(System.String,System.Enum@)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetEnum(System.Int32,System.Enum@)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetEnum(System.String,System.Enum)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetEnum(System.Int32,System.Enum)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetEnum``1(System.String,``0)">
            <summary>
            It wants to set the value of the Enum type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetEnum``1(System.Int32,``0)">
            <summary>
            It wants to set the value of the Enum type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetEnum``1(System.String,``0@)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetEnum``1(System.Int32,``0@)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetEnum``1(System.String,``0)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetEnum``1(System.String)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="name">Name.</param>
            <returns>The value of the parameter. If there is no parameter, it returns default(TEnum).</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetEnum``1(System.Int32,``0)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetEnum``1(System.Int32)">
            <summary>
            Get the value of the Enum type.
            </summary>
            <param name="id">ID.</param>
            <returns>The value of the parameter. If there is no parameter, it returns default(TEnum).</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetGameObject(System.String,UnityEngine.GameObject)">
            <summary>
            It wants to set the value of the GameObject type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetGameObject(System.Int32,UnityEngine.GameObject)">
            <summary>
            It wants to set the value of the GameObject type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetGameObject(System.String,UnityEngine.GameObject@)">
            <summary>
            Get the value of the GameObject type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetGameObject(System.Int32,UnityEngine.GameObject@)">
            <summary>
            Get the value of the GameObject type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetGameObject(System.String,UnityEngine.GameObject)">
            <summary>
            Get the value of the GameObject type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetGameObject(System.Int32,UnityEngine.GameObject)">
            <summary>
            Get the value of the GameObject type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetGameObject(System.String,UnityEngine.GameObject@)">
            <summary>
            Get the value of the GameObject type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetGameObject(System.Int32,UnityEngine.GameObject@)">
            <summary>
            Get the value of the GameObject type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetVector2(System.String,UnityEngine.Vector2)">
            <summary>
            It wants to set the value of the Vector2 type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetVector2(System.Int32,UnityEngine.Vector2)">
            <summary>
            It wants to set the value of the Vector2 type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetVector2(System.String,UnityEngine.Vector2@)">
            <summary>
            Get the value of the Vector2 type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetVector2(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Get the value of the Vector2 type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetVector2(System.String,UnityEngine.Vector2)">
            <summary>
            Get the value of the Vector2 type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetVector2(System.String)">
            <summary>
            Get the value of the Vector2 type.
            </summary>
            <param name="name">Name.</param>
            <returns>The value of the parameter. If there is no parameter, it returns Vector2.zero.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetVector2(System.Int32,UnityEngine.Vector2)">
            <summary>
            Get the value of the Vector2 type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetVector2(System.Int32)">
            <summary>
            Get the value of the Vector2 type.
            </summary>
            <param name="id">ID.</param>
            <returns>The value of the parameter. If there is no parameter, it returns Vector2.zero.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetVector2(System.String,UnityEngine.Vector2@)">
            <summary>
            Get the value of the Vector2 type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetVector2(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Get the value of the Vector2 type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetVector3(System.String,UnityEngine.Vector3)">
            <summary>
            It wants to set the value of the Vector3 type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetVector3(System.Int32,UnityEngine.Vector3)">
            <summary>
            It wants to set the value of the Vector3 type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetVector3(System.String,UnityEngine.Vector3@)">
            <summary>
            Get the value of the Vector3 type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetVector3(System.Int32,UnityEngine.Vector3@)">
            <summary>
            Get the value of the Vector3 type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetVector3(System.String,UnityEngine.Vector3)">
            <summary>
            Get the value of the Vector3 type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetVector3(System.String)">
            <summary>
            Get the value of the Vector3 type.
            </summary>
            <param name="name">Name.</param>
            <returns>The value of the parameter. If there is no parameter, it returns Vector3.zero.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetVector3(System.Int32,UnityEngine.Vector3)">
            <summary>
            Get the value of the Vector3 type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetVector3(System.Int32)">
            <summary>
            Get the value of the Vector3 type.
            </summary>
            <param name="id">ID.</param>
            <returns>The value of the parameter. If there is no parameter, it returns Vector3.zero.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetVector3(System.String,UnityEngine.Vector3@)">
            <summary>
            Get the value of the Vector3 type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetVector3(System.Int32,UnityEngine.Vector3@)">
            <summary>
            Get the value of the Vector3 type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetQuaternion(System.String,UnityEngine.Quaternion)">
            <summary>
            It wants to set the value of the Quaternion type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetQuaternion(System.Int32,UnityEngine.Quaternion)">
            <summary>
            It wants to set the value of the Quaternion type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetQuaternion(System.String,UnityEngine.Quaternion@)">
            <summary>
            Get the value of the Quaternion type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetQuaternion(System.Int32,UnityEngine.Quaternion@)">
            <summary>
            Get the value of the Quaternion type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetQuaternion(System.String,UnityEngine.Quaternion)">
            <summary>
            Get the value of the Quaternion type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetQuaternion(System.String)">
            <summary>
            Get the value of the Quaternion type.
            </summary>
            <param name="name">Name.</param>
            <returns>The value of the parameter. If there is no parameter, it returns Quaternion.identity.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetQuaternion(System.Int32,UnityEngine.Quaternion)">
            <summary>
            Get the value of the Quaternion type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetQuaternion(System.Int32)">
            <summary>
            Get the value of the Quaternion type.
            </summary>
            <param name="id">ID.</param>
            <returns>The value of the parameter. If there is no parameter, it returns Quaternion.identity.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetQuaternion(System.String,UnityEngine.Quaternion@)">
            <summary>
            Get the value of the Quaternion type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetQuaternion(System.Int32,UnityEngine.Quaternion@)">
            <summary>
            Get the value of the Quaternion type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetRect(System.String,UnityEngine.Rect)">
            <summary>
            It wants to set the value of the Rect type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetRect(System.Int32,UnityEngine.Rect)">
            <summary>
            It wants to set the value of the Rect type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetRect(System.String,UnityEngine.Rect@)">
            <summary>
            Get the value of the Rect type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetRect(System.Int32,UnityEngine.Rect@)">
            <summary>
            Get the value of the Rect type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRect(System.String,UnityEngine.Rect)">
            <summary>
            Get the value of the Rect type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRect(System.String)">
            <summary>
            Get the value of the Rect type.
            </summary>
            <param name="name">Name.</param>
            <returns>The value of the parameter. If there is no parameter, it returns Rect(0, 0, 0, 0).</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRect(System.Int32,UnityEngine.Rect)">
            <summary>
            Get the value of the Rect type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRect(System.Int32)">
            <summary>
            Get the value of the Rect type.
            </summary>
            <param name="id">ID.</param>
            <returns>The value of the parameter. If there is no parameter, it returns Rect(0, 0, 0, 0).</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRect(System.String,UnityEngine.Rect@)">
            <summary>
            Get the value of the Rect type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRect(System.Int32,UnityEngine.Rect@)">
            <summary>
            Get the value of the Rect type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetBounds(System.String,UnityEngine.Bounds)">
            <summary>
            It wants to set the value of the Bounds type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetBounds(System.Int32,UnityEngine.Bounds)">
            <summary>
            It wants to set the value of the Bounds type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetBounds(System.String,UnityEngine.Bounds@)">
            <summary>
            Get the value of the Bounds type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetBounds(System.Int32,UnityEngine.Bounds@)">
            <summary>
            Get the value of the Bounds type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetBounds(System.String,UnityEngine.Bounds)">
            <summary>
            Get the value of the Bounds type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetBounds(System.String)">
            <summary>
            Get the value of the Bounds type.
            </summary>
            <param name="name">Name.</param>
            <returns>The value of the parameter. If there is no parameter, it returns 0 bounds.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetBounds(System.Int32,UnityEngine.Bounds)">
            <summary>
            Get the value of the Bounds type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetBounds(System.Int32)">
            <summary>
            Get the value of the Bounds type.
            </summary>
            <param name="id">ID.</param>
            <returns>The value of the parameter. If there is no parameter, it returns 0 bounds.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetBounds(System.String,UnityEngine.Bounds@)">
            <summary>
            Get the value of the Bounds type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetBounds(System.Int32,UnityEngine.Bounds@)">
            <summary>
            Get the value of the Bounds type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetColor(System.String,UnityEngine.Color)">
            <summary>
            It wants to set the value of the Color type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetColor(System.Int32,UnityEngine.Color)">
            <summary>
            It wants to set the value of the Color type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetColor(System.String,UnityEngine.Color@)">
            <summary>
            Get the value of the Color type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetColor(System.Int32,UnityEngine.Color@)">
            <summary>
            Get the value of the Color type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetColor(System.String,UnityEngine.Color)">
            <summary>
            Get the value of the Color type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetColor(System.String)">
            <summary>
            Get the value of the Color type.
            </summary>
            <param name="name">Name.</param>
            <returns>The value of the parameter. If there is no parameter, it returns Color.white.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetColor(System.Int32,UnityEngine.Color)">
            <summary>
            Get the value of the Color type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetColor(System.Int32)">
            <summary>
            Get the value of the Color type.
            </summary>
            <param name="id">ID.</param>
            <returns>The value of the parameter. If there is no parameter, it returns Color.white.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetColor(System.String,UnityEngine.Color@)">
            <summary>
            Get the value of the Color type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetColor(System.Int32,UnityEngine.Color@)">
            <summary>
            Get the value of the Color type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetTransform(System.String,UnityEngine.Transform)">
            <summary>
            It wants to set the value of the Transform type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetTransform(System.Int32,UnityEngine.Transform)">
            <summary>
            It wants to set the value of the Transform type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetTransform(System.String,UnityEngine.Transform@)">
            <summary>
            Get the value of the Transform type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetTransform(System.Int32,UnityEngine.Transform@)">
            <summary>
            Get the value of the Transform type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetTransform(System.String,UnityEngine.Transform)">
            <summary>
            Get the value of the Transform type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetTransform(System.Int32,UnityEngine.Transform)">
            <summary>
            Get the value of the Transform type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetTransform(System.String,UnityEngine.Transform@)">
            <summary>
            Get the value of the Transform type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetTransform(System.Int32,UnityEngine.Transform@)">
            <summary>
            Get the value of the Transform type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetRectTransform(System.String,UnityEngine.RectTransform)">
            <summary>
            It wants to set the value of the RectTransform type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetRectTransform(System.Int32,UnityEngine.RectTransform)">
            <summary>
            It wants to set the value of the RectTransform type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetRectTransform(System.String,UnityEngine.RectTransform@)">
            <summary>
            Get the value of the RectTransform type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetRectTransform(System.Int32,UnityEngine.RectTransform@)">
            <summary>
            Get the value of the RectTransform type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRectTransform(System.String,UnityEngine.RectTransform)">
            <summary>
            Get the value of the RectTransform type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRectTransform(System.Int32,UnityEngine.RectTransform)">
            <summary>
            Get the value of the RectTransform type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRectTransform(System.String,UnityEngine.RectTransform@)">
            <summary>
            Get the value of the RectTransform type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRectTransform(System.Int32,UnityEngine.RectTransform@)">
            <summary>
            Get the value of the RectTransform type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetRigidbody(System.String,UnityEngine.Rigidbody)">
            <summary>
            It wants to set the value of the Rigidbody type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetRigidbody(System.Int32,UnityEngine.Rigidbody)">
            <summary>
            It wants to set the value of the Rigidbody type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetRigidbody(System.String,UnityEngine.Rigidbody@)">
            <summary>
            Get the value of the Rigidbody type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetRigidbody(System.Int32,UnityEngine.Rigidbody@)">
            <summary>
            Get the value of the Rigidbody type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRigidbody(System.String,UnityEngine.Rigidbody)">
            <summary>
            Get the value of the Rigidbody type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRigidbody(System.Int32,UnityEngine.Rigidbody)">
            <summary>
            Get the value of the Rigidbody type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The value of the parameter. If there is no parameter, it returns defaultValue.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRigidbody(System.String,UnityEngine.Rigidbody@)">
            <summary>
            Get the value of the Rigidbody type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRigidbody(System.Int32,UnityEngine.Rigidbody@)">
            <summary>
            Get the value of the Rigidbody type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetRigidbody2D(System.String,UnityEngine.Rigidbody2D)">
            <summary>
            It wants to set the value of the Rigidbody2D type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.SetRigidbody2D(System.Int32,UnityEngine.Rigidbody2D)">
            <summary>
            It wants to set the value of the Rigidbody2D type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">Value.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetRigidbody2D(System.String,UnityEngine.Rigidbody2D@)">
            <summary>
            Get the value of the Rigidbody2D type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.TryGetRigidbody2D(System.Int32,UnityEngine.Rigidbody2D@)">
            <summary>
            Get the value of the Rigidbody2D type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRigidbody2D(System.String,UnityEngine.Rigidbody2D)">
            <summary>
            Get the value of the Rigidbody2D type.
            </summary>
            <param name="name">Name.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRigidbody2D(System.Int32,UnityEngine.Rigidbody2D)">
            <summary>
            Get the value of the Rigidbody2D type.
            </summary>
            <param name="id">ID.</param>
            <param name="defaultValue">Default value. It is returned when there is no parameter.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRigidbody2D(System.String,UnityEngine.Rigidbody2D@)">
            <summary>
            Get the value of the Rigidbody2D type.
            </summary>
            <param name="name">Name.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.GetRigidbody2D(System.Int32,UnityEngine.Rigidbody2D@)">
            <summary>
            Get the value of the Rigidbody2D type.
            </summary>
            <param name="id">ID.</param>
            <param name="value">The value you get.</param>
            <returns>The true when there parameters of the specified name.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.FindParameterContainsVariable(Arbor.VariableBase)">
            <summary>
            Acquisition of parameters VariableBase belongs.
            </summary>
            <param name="variable">VariableBase</param>
            <returns>Parameters VariableBase belongs. Return null if not.</returns>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.DestroySubComponents">
            <summary>
            Method to be used internally. In particular there is no need to call.
            </summary>
        </member>
        <member name="M:Arbor.ParameterContainerInternal.Destroy(Arbor.ParameterContainerInternal)">
            <summary>
            Destroy ParameterContainerInternal
            </summary>
            <param name="parameterContainer">ParameterContainerInternal</param>
        </member>
        <member name="P:Arbor.ParameterContainerInternal.isDeserialized">
            <summary>
            Returns whether or not deserialization has been done.
            </summary>
        </member>
        <member name="E:Arbor.ParameterContainerInternal.onAfterDeserialize">
            <summary>
            Callback after deserialization
            </summary>
        </member>
        <member name="T:Arbor.AnyParameterReference">
            <summary>
            Parameter reference specifying type.
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.ClassTypeConstraintAttribute" /></description></item>
            <item><description><see cref="T:Arbor.SlotTypeAttribute" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Arbor.AnyParameterReference.parameterType">
            <summary>
            Parameter Type
            </summary>
        </member>
        <member name="M:Arbor.AnyParameterReference.#ctor">
            <summary>
            Create AnyParameterReference
            </summary>
        </member>
        <member name="M:Arbor.AnyParameterReference.#ctor(System.Type)">
            <summary>
            Create AnyParameterReference
            </summary>
            <param name="parameterType">Parameter Type</param>
        </member>
        <member name="T:Arbor.BoolParameterReference">
            <summary>
            Reference Bool parameters.
            </summary>
        </member>
        <member name="T:Arbor.BoundsParameterReference">
            <summary>
            Reference Bounds parameters.
            </summary>
        </member>
        <member name="T:Arbor.ColorParameterReference">
            <summary>
            Reference Color parameters.
            </summary>
        </member>
        <member name="T:Arbor.ComponentParameterReference">
            <summary>
            Reference Component parameters.
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.ClassTypeConstraintAttribute" /></description></item>
            <item><description><see cref="T:Arbor.SlotTypeAttribute" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Arbor.FloatParameterReference">
            <summary>
            Reference Float parameters.
            </summary>
        </member>
        <member name="T:Arbor.GameObjectParameterReference">
            <summary>
            Reference GameObject parameters.
            </summary>
        </member>
        <member name="T:Arbor.IntParameterReference">
            <summary>
            Reference Int parameters.
            </summary>
        </member>
        <member name="T:Arbor.LongParameterReference">
            <summary>
            Reference Long parameters.
            </summary>
        </member>
        <member name="T:Arbor.ParameterReference">
            <summary>
            Reference parameters.
            </summary>
        </member>
        <member name="F:Arbor.ParameterReference.id">
            <summary>
            ID.
            </summary>
        </member>
        <member name="F:Arbor.ParameterReference.name">
            <summary>
            Paramenter name.
            </summary>
        </member>
        <member name="P:Arbor.ParameterReference.type">
            <summary>
            Reference type of ParameterContainer
            </summary>
        </member>
        <member name="P:Arbor.ParameterReference.container">
            <summary>
            Is stored to that container.
            </summary>
        </member>
        <member name="P:Arbor.ParameterReference.referenceType">
            <summary>
            Returns the <see cref="T:Arbor.Parameter.Type"/> to be referenced.
            </summary>
        </member>
        <member name="P:Arbor.ParameterReference.parameter">
            <summary>
            Get the parameters. null if it does not exist.
            </summary>
        </member>
        <member name="T:Arbor.ParameterReferenceType">
            <summary>
            Reference type used in ParameterReference class
            </summary>
        </member>
        <member name="F:Arbor.ParameterReferenceType.Constant">
            <summary>
            Constant
            </summary>
        </member>
        <member name="F:Arbor.ParameterReferenceType.DataSlot">
            <summary>
            Data slot
            </summary>
        </member>
        <member name="T:Arbor.QuaternionParameterReference">
            <summary>
            Reference Bool parameters.
            </summary>
        </member>
        <member name="T:Arbor.RectParameterReference">
            <summary>
            Reference Rect parameters.
            </summary>
        </member>
        <member name="T:Arbor.RectTransformParameterReference">
            <summary>
            Reference RectTransform parameters.
            </summary>
        </member>
        <member name="T:Arbor.Rigidbody2DParameterReference">
            <summary>
            Reference Transform parameters.
            </summary>
        </member>
        <member name="T:Arbor.RigidbodyParameterReference">
            <summary>
            Reference Rigidbody parameters.
            </summary>
        </member>
        <member name="T:Arbor.StringParameterReference">
            <summary>
            Reference String parameters.
            </summary>
        </member>
        <member name="T:Arbor.TransformParameterReference">
            <summary>
            Reference Transform parameters.
            </summary>
        </member>
        <member name="T:Arbor.Vector2ParameterReference">
            <summary>
            Reference Vector2 parameters.
            </summary>
        </member>
        <member name="T:Arbor.Vector3ParameterReference">
            <summary>
            Reference Vector3 parameters.
            </summary>
        </member>
        <member name="T:Arbor.PlayState">
            <summary>
            Play state
            </summary>
        </member>
        <member name="F:Arbor.PlayState.Stopping">
            <summary>
            Stopping
            </summary>
        </member>
        <member name="F:Arbor.PlayState.Playing">
            <summary>
            Playing
            </summary>
        </member>
        <member name="F:Arbor.PlayState.Pausing">
            <summary>
            Pausing
            </summary>
        </member>
        <member name="T:Arbor.ProfilerScope">
            <summary>
            Disposable helper class that manages the Profiler.BeginSample / EndSample.
            <para>Simple to use the using You can write Profiler.BeginSample / EndSample.</para>
            </summary>
        </member>
        <member name="M:Arbor.ProfilerScope.#ctor(System.String)">
            <summary>
            Create a new ProfilerScope, to start the sampling of the profiler.
            </summary>
            <param name="name">The name of the sampling</param>
        </member>
        <member name="M:Arbor.ProfilerScope.Dispose">
            <summary>
            Dispose.
            </summary>
        </member>
        <member name="T:Arbor.ScriptableSingleton`1">
            <summary>
            Class that the ScriptableObject to Singleton.
            </summary>
        </member>
        <member name="P:Arbor.ScriptableSingleton`1.instance">
            <summary>
            To get an instance.
            </summary>
        </member>
        <member name="T:Arbor.Serialization.SerializationUtility">
            <summary>
            Utility class for Unity serialization
            </summary>
        </member>
        <member name="M:Arbor.Serialization.SerializationUtility.IsSupportedArray(System.Type)">
            <summary>
            Returns whether it is an array supported.
            </summary>
            <param name="type">Determining type</param>
            <returns>Returns true if the array is supported.</returns>
        </member>
        <member name="M:Arbor.Serialization.SerializationUtility.ElementTypeOfArray(System.Type)">
            <summary>
            Returns the type of the array element.
            </summary>
            <param name="type">Array type</param>
            <returns>The type of the array element</returns>
        </member>
        <member name="M:Arbor.Serialization.SerializationUtility.ElementType(System.Type)">
            <summary>
            If it is an array it returns the type of the element.
            </summary>
            <param name="type">Type</param>
            <returns>If it is an array it returns the type of the element. Otherwise return type unchanged.</returns>
        </member>
        <member name="M:Arbor.Serialization.SerializationUtility.IsSerializableFieldType(System.Type)">
            <summary>
            Returns whether the field type is serializable.
            </summary>
            <param name="type">Field type</param>
            <returns>Returns true if serializable.</returns>
        </member>
        <member name="T:Arbor.Serialization.SerializeFieldInfo">
            <summary>
            Information on the serialized field
            </summary>
        </member>
        <member name="P:Arbor.Serialization.SerializeFieldInfo.elementType">
            <summary>
            Element type
            </summary>
        </member>
        <member name="P:Arbor.Serialization.SerializeFieldInfo.fieldInfo">
            <summary>
            Getting FieldInfo.
            </summary>
        </member>
        <member name="P:Arbor.Serialization.SerializeFieldInfo.isClass">
            <summary>
            Return whether the field type is a class
            </summary>
        </member>
        <member name="M:Arbor.Serialization.SerializeFieldInfo.#ctor(System.Reflection.FieldInfo,System.Type)">
            <summary>
            Initializes a new instance of the SerializeFieldInfo class.
            </summary>
            <param name="fieldInfo">FieldInfo</param>
            <param name="elementType">Type of field element</param>
        </member>
        <member name="M:Arbor.Serialization.SerializeFieldInfo.GetValue(System.Object)">
            <summary>
            Get the value of the field.
            </summary>
            <param name="instance">Instance</param>
            <returns>Field value</returns>
        </member>
        <member name="T:Arbor.SlotType">
            <summary>
            Types of DataSlot
            </summary>
        </member>
        <member name="F:Arbor.SlotType.Input">
            <summary>
            Input slot
            </summary>
        </member>
        <member name="F:Arbor.SlotType.Output">
            <summary>
            Output slot
            </summary>
        </member>
        <member name="F:Arbor.SlotType.Reroute">
            <summary>
            Reroute slot
            </summary>
        </member>
        <member name="T:Arbor.SlotTypeAttribute">
            <summary>
            An attribute that specifies a connectable type such as <see cref="T:Arbor.ComponentParameterReference" /> or <see cref="T:Arbor.FlexibleComponent" />.
            </summary>
        </member>
        <member name="P:Arbor.SlotTypeAttribute.connectableType">
            <summary>
            Connectable type
            </summary>
        </member>
        <member name="M:Arbor.SlotTypeAttribute.#ctor(System.Type)">
            <summary>
            To create a SlotTypeAttribute by specifying the possible connection types.
            </summary>
            <param name="connectableType">Connectable type</param>
        </member>
        <member name="T:Arbor.State">
            <summary>
            Class that represents the state
            </summary>
        </member>
        <member name="F:Arbor.State.name">
            <summary>
            The name of the state.
            </summary>
        </member>
        <member name="P:Arbor.State.stateMachine">
            <summary>
            Gets the state machine.
            </summary>
        </member>
        <member name="P:Arbor.State.behaviours">
            <summary>
            Deprecated. Use behaviourCount and GetBehaviourFromIndex.
            </summary>
        </member>
        <member name="P:Arbor.State.behaviourCount">
            <summary>
            Get a count of Behavior.
            </summary>
        </member>
        <member name="P:Arbor.State.stateID">
            <summary>
            Gets the state identifier.
            </summary>
        </member>
        <member name="P:Arbor.State.resident">
            <summary>
            Gets a value indicating whether this <see cref="T:Arbor.State"/> is resident.
            </summary>
        </member>
        <member name="P:Arbor.State.breakPoint">
            <summary>
            Break point.
            When this property is true, the editor is in a pause state at the timing of entering the state.
            </summary>
        </member>
        <member name="P:Arbor.State.transitionCount">
            <summary>
            Transition count.
            </summary>
        </member>
        <member name="M:Arbor.State.#ctor(Arbor.ArborFSMInternal,System.Int32,System.Boolean)">
            <summary>
            State constructor
            </summary>
            <param name="stateMachine">StateMachine with this node</param>
            <param name="nodeID">Node ID</param>
            <param name="resident">Resident state</param>
            <remarks>
            Please use the <see cref = "M:Arbor.ArborFSMInternal.CreateState(System.Boolean)" /> state creating.
            </remarks>
        </member>
        <member name="M:Arbor.State.AddBehaviour(Arbor.StateBehaviour)">
            <summary>
            Adds the behaviour.
            </summary>
            <param name="behaviour">Add StateBehaviour</param>
        </member>
        <member name="M:Arbor.State.AddBehaviour(System.Type)">
            <summary>
            Adds the behaviour.
            </summary>
            <param name="type">Type of add StateBehaviour</param>
            <returns>Added StateBehaviour</returns>
        </member>
        <member name="M:Arbor.State.AddBehaviour``1">
            <summary>
            Adds the behaviour.
            </summary>
            <typeparam name="T">Type of add StateBehaviour</typeparam>
            <returns>Added StateBehaviour</returns>
        </member>
        <member name="M:Arbor.State.InsertBehaviour(System.Int32,Arbor.StateBehaviour)">
            <summary>
            Insert the behaviour.
            </summary>
            <param name="index">Insertion destination index</param>
            <param name="behaviour">Insert StateBehaviour</param>
        </member>
        <member name="M:Arbor.State.InsertBehaviour(System.Int32,System.Type)">
            <summary>
            Insert the behaviour.
            </summary>
            <param name="index">Insertion destination index</param>
            <param name="type">Type of add StateBehaviour</param>
            <returns>Inserted StateBehaviour</returns>
        </member>
        <member name="M:Arbor.State.InsertBehaviour``1(System.Int32)">
            <summary>
            Adds the behaviour.
            </summary>
            <typeparam name="T">Type of insert StateBehaviour</typeparam>
            <param name="index">Insertion destination index</param>
            <returns>Inserted StateBehaviour</returns>
        </member>
        <member name="M:Arbor.State.GetBehaviourFromIndex(System.Int32)">
            <summary>
            Get StateBehavior from index.
            </summary>
            <param name="index">Index</param>
            <returns>StateBehaviour</returns>
        </member>
        <member name="M:Arbor.State.GetBehaviourObjectFromIndex(System.Int32)">
            <summary>
            Get Object of StateBehavior from index.
            </summary>
            <param name="index">Index</param>
            <returns>Object</returns>
        </member>
        <member name="M:Arbor.State.GetBehaviour(System.Type)">
            <summary>
            Gets the behaviour.
            </summary>
            <param name="type">Type of you want to get StateBehaviour.</param>
            <returns>Found StateBehaviour. Or null if it is not.</returns>
        </member>
        <member name="M:Arbor.State.GetBehaviour``1">
            <summary>
            Gets the behaviour.
            </summary>
            <typeparam name="T">Type of you want to get StateBehaviour.</typeparam>
            <returns>Found StateBehaviour. Or null if it is not.</returns>
        </member>
        <member name="M:Arbor.State.GetBehaviours(System.Type)">
            <summary>
            Gets the behaviours.
            </summary>
            <param name="type">Type of you want to get StateBehaviour.</param>
            <returns>Array of found StateBehaviour.</returns>
        </member>
        <member name="M:Arbor.State.GetBehaviours``1">
            <summary>
            Gets the behaviours.
            </summary>
            <typeparam name="T">Type of you want to get StateBehaviour.</typeparam>
            <returns>Array of found StateBehaviour.</returns>
        </member>
        <member name="M:Arbor.State.Contains(Arbor.StateBehaviour)">
            <summary>
            Whether StateBehaviour are included.
            </summary>
            <param name="behaviour">Judges StateBehaviour.</param>
            <returns>Whether included are.</returns>
        </member>
        <member name="M:Arbor.State.IndexOfBehaviour(UnityEngine.Object)">
            <summary>
            Return index of StateBehaviour.
            </summary>
            <param name="behaviourObj">The StateBehaviour to locate in the State.</param>
            <returns>Returns an index if found, -1 otherwise.</returns>
        </member>
        <member name="M:Arbor.State.RemoveBehaviour(UnityEngine.Object)">
            <summary>
            I want to remove the StateBehaviour. For instance is not deleted, that you use the <see cref = "M:Arbor.StateBehaviour.Destroy" />.
            </summary>
            <param name="behaviourObj">StateBehaviour you want to remove.</param>
        </member>
        <member name="M:Arbor.State.SwapBehaviour(System.Int32,System.Int32)">
            <summary>
            Swap the order of StateBehaviour.
            </summary>
            <param name="fromIndex">The swapping want index.</param>
            <param name="toIndex">Exchange destination index.</param>
        </member>
        <member name="M:Arbor.State.MoveBehaviour(System.Int32,Arbor.State,System.Int32)">
            <summary>
            Move the order of StateBehaviour.
            </summary>
            <param name="fromIndex">The moving want index.</param>
            <param name="toState">The destination State.</param>
            <param name="toIndex">The destination index.</param>
        </member>
        <member name="M:Arbor.State.SetBehaviour(System.Int32,Arbor.StateBehaviour)">
            <summary>
            Set StateBehaviour.
            </summary>
            <param name="index">Index</param>
            <param name="behaviour">StateBehaviour</param>
            <remarks>
            Note that the original StateBehaviour does not Destroy.
            If you want to add StateBehaviour, please use AddBehaviour.
            If you want to do Destroy please use DestroyBehaviour.
            </remarks>
        </member>
        <member name="M:Arbor.State.OnGraphChanged">
            <summary>
            Called when the NodeGraph to which the Node belongs has changed.
            </summary>
        </member>
        <member name="M:Arbor.State.IsContainsBehaviour(Arbor.NodeBehaviour)">
            <summary>
            Check if it contains NodeBehaviour.
            </summary>
            <param name="behaviour">Check NodeBehaviour</param>
            <returns>Returns true if it contains NodeBehaviour.</returns>
        </member>
        <member name="M:Arbor.State.DisconnectState(System.Int32)">
            <summary>
            For internal.
            </summary>
        </member>
        <member name="M:Arbor.State.DestroyBehaviour(UnityEngine.Object)">
            <summary>
            Destroy StateBehaviour
            </summary>
            <param name="behaviourObj">The StateBehavior you want to destroy.</param>
        </member>
        <member name="M:Arbor.State.DestroyBehaviours">
            <summary>
            For internal.
            </summary>
        </member>
        <member name="M:Arbor.State.UpdateBehaviours">
            <summary>
            For internal.
            </summary>
        </member>
        <member name="M:Arbor.State.LateUpdateBehaviours">
            <summary>
            For internal.
            </summary>
        </member>
        <member name="M:Arbor.State.SendTrigger(System.String)">
            <summary>
            Send a trigger message.<see cref = "M:Arbor.StateBehaviour.OnStateTrigger(System.String)" /> is called.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Arbor.State.GetName">
            <summary>
            Get node name.
            </summary>
            <returns>Node name</returns>
        </member>
        <member name="T:Arbor.StateBehaviour">
            <summary>
            Class that defines the behavior of the State. Inherited and to use.
            </summary>
            <remarks>
            Available Attributes : <br/>
            <list type="bullet">
            <item><description><see cref="T:Arbor.AddBehaviourMenu" /></description></item>
            <item><description><see cref="T:Arbor.HideBehaviour" /></description></item>
            <item><description><see cref="T:Arbor.BehaviourTitle" /></description></item>
            <item><description><see cref="T:Arbor.BehaviourHelp" /></description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Arbor.StateBehaviour.expanded">
            <summary>
            Expanded on ArborEditorWindow.
            </summary>
        </member>
        <member name="P:Arbor.StateBehaviour.stateMachine">
            <summary>
            Gets the state machine.
            </summary>
        </member>
        <member name="P:Arbor.StateBehaviour.state">
            <summary>
            Get the State.
            </summary>
        </member>
        <member name="P:Arbor.StateBehaviour.stateID">
            <summary>
            Gets the state identifier.
            </summary>
        </member>
        <member name="P:Arbor.StateBehaviour.behaviourEnabled">
            <summary>
            Gets or sets a value indicating whether [behaviour enabled].
            </summary>
            <value>
              <c>true</c> if [behaviour enabled]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Arbor.StateBehaviour.prevTransitionState">
            <summary>
            Prev state
            </summary>
        </member>
        <member name="P:Arbor.StateBehaviour.nextTransitionState">
            <summary>
            Next state
            </summary>
        </member>
        <member name="P:Arbor.StateBehaviour.stateLinkCount">
            <summary>
            Count of StateLink.
            </summary>
        </member>
        <member name="M:Arbor.StateBehaviour.OnInitializeEnabled">
            <summary>
            Called to perform enabled initialization.
            </summary>
        </member>
        <member name="M:Arbor.StateBehaviour.OnStateAwake">
            <summary>
            Called when [state enter first].
            </summary>
        </member>
        <member name="M:Arbor.StateBehaviour.OnStateBegin">
            <summary>
            Called when [state enter].
            </summary>
        </member>
        <member name="M:Arbor.StateBehaviour.OnStateUpdate">
            <summary>
            Update of State. It is called every frame.
            </summary>
        </member>
        <member name="M:Arbor.StateBehaviour.OnStateLateUpdate">
            <summary>
            LateUpdate for State. Every frame, called after all updates.
            </summary>
        </member>
        <member name="M:Arbor.StateBehaviour.OnStateEnd">
            <summary>
            Called when [state exit].
            </summary>
        </member>
        <member name="M:Arbor.StateBehaviour.OnStateTrigger(System.String)">
            <summary>
            Called from SendTrigger.
            </summary>
            <param name="message">Message</param>
        </member>
        <member name="M:Arbor.StateBehaviour.Transition(System.Int32,Arbor.TransitionTiming)">
            <summary>
            State transition
            </summary>
            <param name="nextStateID">State ID for the transition destination.</param>
            <param name="transitionTiming">Transition timing.</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.Transition(System.Int32,System.Boolean)">
            <summary>
            State transition
            </summary>
            <param name="nextStateID">State ID for the transition destination.</param>
            <param name="immediateTransition">Whether or not to transition immediately. If false I will transition to the end of the current frame (when LateUpdate).</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.Transition(System.Int32)">
            <summary>
            State transition. Timing to actually transition current frame last (when LateUpdate).
            </summary>
            <param name="nextStateID">State ID for the transition destination.</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.Transition(Arbor.State,Arbor.TransitionTiming)">
            <summary>
            State transition
            </summary>
            <param name="nextState">Destination state.</param>
            <param name="transitionTiming">Transition timing.</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.Transition(Arbor.State,System.Boolean)">
            <summary>
            State transition
            </summary>
            <param name="nextState">Destination state.</param>
            <param name="immediateTransition">Whether or not to transition immediately. If false I will transition to the end of the current frame (when LateUpdate).</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.Transition(Arbor.State)">
            <summary>
            State transition. Timing to actually transition current frame last (when LateUpdate).
            </summary>
            <param name="nextState">Destination state.</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.Transition(Arbor.StateLink,Arbor.TransitionTiming)">
            <summary>
            State transition
            </summary>
            <param name="nextStateLink">The destination of transition.</param>
            <param name="transitionTiming">Transition timing.</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.Transition(Arbor.StateLink,System.Boolean)">
            <summary>
            State transition
            </summary>
            <param name="nextStateLink">The destination of transition.</param>
            <param name="immediateTransition">Whether or not to transition immediately. If false I will transition to the end of the current frame (when LateUpdate).</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.Transition(Arbor.StateLink)">
            <summary>
            State transition. Timing to actually transition current frame last (when LateUpdate).
            </summary>
            <param name="nextStateLink">The destination of transition.</param>
            <returns>Whether or not the transition</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.AddBehaviour(System.Type)">
            <summary>
            Adds the behaviour.
            </summary>
            <param name="type">Type of add StateBehaviour</param>
            <returns>Added StateBehaviour</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.AddBehaviour``1">
            <summary>
            Adds the behaviour.
            </summary>
            <typeparam name="T">Type of add StateBehaviour</typeparam>
            <returns>Added StateBehaviour</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.GetBehaviour(System.Type)">
            <summary>
            Gets the behaviour.
            </summary>
            <param name="type">Type of you want to get StateBehaviour.</param>
            <returns>Found StateBehaviour. Or null if it is not.</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.GetBehaviour``1">
            <summary>
            Gets the behaviour.
            </summary>
            <typeparam name="T">Type of you want to get StateBehaviour.</typeparam>
            <returns>Found StateBehaviour. Or null if it is not.</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.GetBehaviours(System.Type)">
            <summary>
            Gets the behaviours.
            </summary>
            <param name="type">Type of you want to get StateBehaviour.</param>
            <returns>Array of found StateBehaviour.</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.GetBehaviours``1">
            <summary>
            Gets the behaviours.
            </summary>
            <typeparam name="T">Type of you want to get StateBehaviour.</typeparam>
            <returns>Array of found StateBehaviour.</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.Destroy">
            <summary>
            Destroys this instance.
            </summary>
        </member>
        <member name="M:Arbor.StateBehaviour.GetStateLink(System.Int32)">
            <summary>
            Return StateLink of index.
            </summary>
            <param name="index">Index of StateLink</param>
            <returns>StateLink</returns>
        </member>
        <member name="M:Arbor.StateBehaviour.RebuildStateLinkCache">
            <summary>
            Rebuild StateLink's cache.
            </summary>
        </member>
        <member name="T:Arbor.StateLink">
            <summary>
            Class that contains a transition destination State.
            </summary>
        </member>
        <member name="F:Arbor.StateLink.name">
            <summary>
            Name. The path is displayed if you do not enter.
            </summary>
        </member>
        <member name="F:Arbor.StateLink.stateID">
            <summary>
            ID of transition destination State.
            </summary>
        </member>
        <member name="F:Arbor.StateLink.transitionTiming">
            <summary>
            Transition timing.
            </summary>
        </member>
        <member name="P:Arbor.StateLink.immediateTransition">
            <summary>
            Whether to immediately transition.
            </summary>
        </member>
        <member name="F:Arbor.StateLink.bezier">
            <summary>
            For Editor.
            </summary>
        </member>
        <member name="F:Arbor.StateLink.lineColorChanged">
            <summary>
            For Editor.
            </summary>
        </member>
        <member name="F:Arbor.StateLink.lineColor">
            <summary>
            For Editor.
            </summary>
        </member>
        <member name="P:Arbor.StateLink.transitionCount">
            <summary>
            Transition count.
            </summary>
        </member>
        <member name="P:Arbor.StateLink.isReroute">
            <summary>
            Whether reroute.
            </summary>
        </member>
        <member name="M:Arbor.StateLink.#ctor">
            <summary>
            StateLink constructor
            </summary>
        </member>
        <member name="M:Arbor.StateLink.#ctor(Arbor.StateLink)">
            <summary>
            StateLink copy constructor.
            </summary>
            <param name="stateLink">Copy source StateLink</param>
        </member>
        <member name="T:Arbor.StateLinkRerouteNode">
            <summary>
            StateLink's reroute node
            </summary>
        </member>
        <member name="F:Arbor.StateLinkRerouteNode.link">
            <summary>
            Transition destination state
            </summary>
        </member>
        <member name="F:Arbor.StateLinkRerouteNode.direction">
            <summary>
            Direction of line
            </summary>
        </member>
        <member name="M:Arbor.StateLinkRerouteNode.#ctor(Arbor.NodeGraph,System.Int32)">
            <summary>
            StateLinkRerouteNode constructor
            </summary>
            <param name="nodeGraph">NodeGraph with this node</param>
            <param name="nodeID">Node ID</param>
            <remarks>
            Please use the <see cref = "M:Arbor.ArborFSMInternal.CreateStateLinkRerouteNode(UnityEngine.Vector2)" /> StateLinkRerouteNode creating.
            </remarks>
        </member>
        <member name="T:Arbor.StateLinkRerouteNodeList">
            <summary>
            StateLinkRerouteNode list
            </summary>
        </member>
        <member name="T:Arbor.TimeType">
            <summary>
            Time type
            </summary>
        </member>
        <member name="F:Arbor.TimeType.Normal">
            <summary>
            Use time of current frame considering timeScale.
            </summary>
        </member>
        <member name="F:Arbor.TimeType.Unscaled">
            <summary>
            Use time of current frame without considering timeScale.
            </summary>
        </member>
        <member name="F:Arbor.TimeType.Realtime">
            <summary>
            Use realtime.
            </summary>
        </member>
        <member name="T:Arbor.TimeUtility">
            <summary>
            Time utility class
            </summary>
        </member>
        <member name="M:Arbor.TimeUtility.CurrentTime(Arbor.TimeType)">
            <summary>
            Return current time.
            </summary>
            <param name="type">Time type</param>
            <returns>Current time</returns>
        </member>
        <member name="T:Arbor.TransitionTiming">
            <summary>
            Transition timing.
            </summary>
        </member>
        <member name="F:Arbor.TransitionTiming.LateUpdateOverwrite">
            <summary>
            Reserve to make transition at LateUpdate. Overwrite if already reserved.
            </summary>
        </member>
        <member name="F:Arbor.TransitionTiming.Immediate">
            <summary>
            Transit immediately. Processing is completed in the transition method.
            </summary>
        </member>
        <member name="F:Arbor.TransitionTiming.LateUpdateDontOverwrite">
            <summary>
            Reserve to make transition at LateUpdate. If it is already reserved, do not overwrite it.
            </summary>
        </member>
        <member name="T:Arbor.TypeUtility">
            <summary>
            Type utility class
            </summary>
        </member>
        <member name="M:Arbor.TypeUtility.GetTypeName(System.Type)">
            <summary>
            Returns the name of the type.
            </summary>
            <param name="type">Type</param>
            <returns></returns>
        </member>
        <member name="M:Arbor.TypeUtility.GetSlotTypeName(System.Type)">
            <summary>
            Return type name (for data slot)
            </summary>
            <param name="type">Type</param>
            <returns>Type name</returns>
        </member>
        <member name="M:Arbor.TypeUtility.TidyAssemblyTypeName(System.Type)">
            <summary>
            Convert Type to a serializable string.
            </summary>
            <param name="type">Type value</param>
            <returns>Serializable string</returns>
        </member>
        <member name="M:Arbor.TypeUtility.GetAssemblyType(System.String)">
            <summary>
            Get System.Type from string.
            </summary>
            <param name="assemblyTypeName">Type name</param>
            <returns>System.Type. If assemblyTypeName is empty or null, it returns null.</returns>
        </member>
        <member name="M:Arbor.TypeUtility.GetBaseType(System.Type)">
            <summary>
            Return base type
            </summary>
            <param name="type">Type</param>
            <returns>Base type</returns>
        </member>
        <member name="M:Arbor.TypeUtility.IsGenericType(System.Type)">
            <summary>
            Returns whether type is a generic type.
            </summary>
            <param name="type">Type</param>
            <returns>true</returns>
        </member>
        <member name="M:Arbor.TypeUtility.GetGenericArguments(System.Type)">
            <summary>
            Return an array of generic type arguments.
            </summary>
            <param name="type">Type</param>
            <returns>An array of generic type arguments</returns>
        </member>
        <member name="M:Arbor.TypeUtility.IsGeneric(System.Type,System.Type)">
            <summary>
            Returns whether it is a generic type constructed from the specified generic type definition.
            </summary>
            <param name="type">Type</param>
            <param name="genericTypeDefinition">Generic type definition</param>
            <returns>Return true if type is a generic type constructed from genericTypeDefinition.</returns>
        </member>
        <member name="M:Arbor.TypeUtility.IsPrimitive(System.Type)">
            <summary>
            Returns whether or not it is a primitive type.
            </summary>
            <param name="type">Type</param>
            <returns>Returns true if it is a primitive type.</returns>
        </member>
        <member name="M:Arbor.TypeUtility.IsEnum(System.Type)">
            <summary>
            Returns whether or not it is an enumeration.
            </summary>
            <param name="type">Type</param>
            <returns>Return true if it is an enumeration.</returns>
        </member>
        <member name="M:Arbor.TypeUtility.IsClass(System.Type)">
            <summary>
            Returns whether or not it is a class type.
            </summary>
            <param name="type">Type</param>
            <returns>Returns true if it is a class type.</returns>
        </member>
        <member name="M:Arbor.TypeUtility.IsSerializable(System.Type)">
            <summary>
            Returns whether it is serializable.
            </summary>
            <param name="type">Type</param>
            <returns>Returns true if serializable.</returns>
        </member>
        <member name="M:Arbor.TypeUtility.IsAbstract(System.Type)">
            <summary>
            Returns whether or not it is an abstract type.
            </summary>
            <param name="type">Type</param>
            <returns>Returns true if it is an abstract type.</returns>
        </member>
        <member name="M:Arbor.TypeUtility.ContainsGenericParameters(System.Type)">
            <summary>
            Returns whether or not it contains a generic type parameter.
            </summary>
            <param name="type">Type</param>
            <returns>Returns true if it contains a generic type parameter.</returns>
        </member>
        <member name="M:Arbor.TypeUtility.GetMemberInfo(System.Type)">
            <summary>
            Get MemberInfo
            </summary>
            <param name="type">Type</param>
            <returns>MemberInfo</returns>
        </member>
        <member name="M:Arbor.TypeUtility.IsSubclassOf(System.Type,System.Type)">
            <summary>
            Determine whether it is a derived type or not.
            </summary>
            <param name="type">Type</param>
            <param name="c">Type to be compared</param>
            <returns>Returns true if type is derived from c.</returns>
        </member>
        <member name="M:Arbor.TypeUtility.IsAssignableFrom(System.Type,System.Type)">
            <summary>
            It is judged whether or not it is an assignable type.
            </summary>
            <param name="type"></param>
            <param name="c">Type to be compared</param>
            <returns>Returns true if an instance of c can be assigned to an instance of type.</returns>
        </member>
        <member name="T:Arbor.UpdateSettings">
            <summary>
            Settings related to updating.
            </summary>
        </member>
        <member name="F:Arbor.UpdateSettings.type">
            <summary>
            Update type.
            </summary>
        </member>
        <member name="F:Arbor.UpdateSettings.timeType">
            <summary>
            Time type(only SpecifySeconds).
            </summary>
        </member>
        <member name="F:Arbor.UpdateSettings.seconds">
            <summary>
            Update interval(only SpecifySeconds).
            </summary>
        </member>
        <member name="P:Arbor.UpdateSettings.isUpdatableOnUpdate">
            <summary>
            It returns whether it can be updated with Update()
            </summary>
        </member>
        <member name="M:Arbor.UpdateSettings.ClearTime">
            <summary>
            Clear update time
            </summary>
        </member>
        <member name="T:Arbor.UpdateType">
            <summary>
            Update type.
            </summary>
        </member>
        <member name="F:Arbor.UpdateType.EveryFrame">
            <summary>
            Update every frame.
            </summary>
        </member>
        <member name="F:Arbor.UpdateType.SpecifySeconds">
            <summary>
            Updated by specifying seconds.
            </summary>
        </member>
        <member name="F:Arbor.UpdateType.Manual">
            <summary>
            Update manually.<br/>
            Refer to the script reference of Component for the update method.
            </summary>
        </member>
        <member name="T:Arbor.FlexibleAnimationCurve">
            <summary>
            Class to handle a flexible AnimationCurve type reference method there is more than one.
            </summary>
        </member>
        <member name="M:Arbor.FlexibleAnimationCurve.#ctor(UnityEngine.AnimationCurve)">
            <summary>
            FlexibleAnimationCurve constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleAnimationCurve.#ctor(Arbor.AnyParameterReference)">
            <summary>
            FlexibleAnimationCurve constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleAnimationCurve.#ctor(Arbor.InputSlotAny)">
            <summary>
            FlexibleAnimationCurve constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleAnimationCurve.op_Explicit(Arbor.FlexibleAnimationCurve)~UnityEngine.AnimationCurve">
            <summary>
            Cast FlexibleAnimationCurve to AnimationCurve.
            </summary>
            <param name="flexible">FlexibleAnimationCurve</param>
        </member>
        <member name="M:Arbor.FlexibleAnimationCurve.op_Explicit(UnityEngine.AnimationCurve)~Arbor.FlexibleAnimationCurve">
            <summary>
            Cast AnimationCurve to FlexibleAnimationCurve.
            </summary>
            <param name="value">AnimationCurve</param>
        </member>
        <member name="T:Arbor.InputSlotAnimationCurve">
            <summary>
            AnimationCurve type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotAnimationCurve">
            <summary>
            AnimationCurve type of output slot
            </summary>
        </member>
        <member name="T:Arbor.AnimationCurveVariable">
            <summary>
            AnimationCurve type Variable
            </summary>
        </member>
        <member name="T:Arbor.FlexibleGradient">
            <summary>
            Class to handle a flexible Gradient type reference method there is more than one.
            </summary>
        </member>
        <member name="M:Arbor.FlexibleGradient.#ctor(UnityEngine.Gradient)">
            <summary>
            FlexibleGradient constructor
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:Arbor.FlexibleGradient.#ctor(Arbor.AnyParameterReference)">
            <summary>
            FlexibleGradient constructor
            </summary>
            <param name="parameter">Parameter</param>
        </member>
        <member name="M:Arbor.FlexibleGradient.#ctor(Arbor.InputSlotAny)">
            <summary>
            FlexibleGradient constructor
            </summary>
            <param name="slot">Slot</param>
        </member>
        <member name="M:Arbor.FlexibleGradient.op_Explicit(Arbor.FlexibleGradient)~UnityEngine.Gradient">
            <summary>
            Cast FlexibleGradient to Gradient.
            </summary>
            <param name="flexible">FlexibleGradient</param>
        </member>
        <member name="M:Arbor.FlexibleGradient.op_Explicit(UnityEngine.Gradient)~Arbor.FlexibleGradient">
            <summary>
            Cast Gradient to FlexibleGradient.
            </summary>
            <param name="value">Gradient</param>
        </member>
        <member name="T:Arbor.InputSlotGradient">
            <summary>
            Gradient type of input slot
            </summary>
        </member>
        <member name="T:Arbor.OutputSlotGradient">
            <summary>
            Gradient type of output slot
            </summary>
        </member>
        <member name="T:Arbor.GradientVariable">
            <summary>
            Gradient type Variable
            </summary>
        </member>
        <member name="T:Arbor.Variable`1">
            <summary>
            A generic class of Variable.
            </summary>
            <typeparam name="T">Type of parameter to be stored in Variable</typeparam>
        </member>
        <member name="P:Arbor.Variable`1.valueType">
            <summary>
            Value type of parameter
            </summary>
        </member>
        <member name="P:Arbor.Variable`1.valueObject">
            <summary>
            Value object
            </summary>
        </member>
        <member name="P:Arbor.Variable`1.value">
            <summary>
            Value of Variable
            </summary>
        </member>
        <member name="T:Arbor.VariableBase">
            <summary>
            Base class of Variable.
            </summary>
        </member>
        <member name="P:Arbor.VariableBase.valueType">
            <summary>
            Value type of parameter
            </summary>
        </member>
        <member name="P:Arbor.VariableBase.valueObject">
            <summary>
            Value object
            </summary>
        </member>
        <member name="P:Arbor.VariableBase.parameterContainer">
            <summary>
            Gets the NodeGraph.
            </summary>
        </member>
        <member name="M:Arbor.VariableBase.GetDataType(System.Type)">
            <summary>
            Get the data type possessed by the Variable class.
            </summary>
            <param name="variableClassType">Variable class type</param>
            <returns>Data type</returns>
        </member>
        <member name="M:Arbor.VariableBase.Initialize(Arbor.ParameterContainerInternal)">
            <summary>
            For Editor.
            </summary>
            <param name="container">ParameterContainerInternal</param>
        </member>
        <member name="M:Arbor.VariableBase.Create(Arbor.ParameterContainerInternal,System.Type)">
            <summary>
            For Editor.
            </summary>
        </member>
    </members>
</doc>
